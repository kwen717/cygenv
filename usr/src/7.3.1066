To: vim_dev@googlegroups.com
Subject: Patch 7.3.1066
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.3.1066
Problem:    Python: Insufficient exception and error testing.
Solution:   Python patch 25. (ZyX)
Files:	    src/testdir/test86.in, src/testdir/test86.ok,
	    src/testdir/test87.in, src/testdir/test87.ok


*** ../vim-7.3.1065/src/testdir/test86.in	2013-05-30 13:14:06.000000000 +0200
--- src/testdir/test86.in	2013-05-30 13:25:22.000000000 +0200
***************
*** 7,12 ****
--- 7,13 ----
  
  STARTTEST
  :so small.vim
+ :set encoding=latin1
  :if !has('python') | e! test.ok | wq! test.out | endif
  :lang C
  :py import vim
***************
*** 785,800 ****
  :$put =string(pyeval('dl2'))
  :$put =string(pyeval('df(2)'))
  :"
! :" Test exceptions
! :fun Exe(e)
! :   execute a:e
  :endfun
  py << EOF
  def ee(expr, g=globals(), l=locals()):
      try:
          exec(expr, g, l)
      except:
!         cb.append(repr(sys.exc_info()[:2]))
  Exe = vim.bindeval('function("Exe")')
  ee('vim.command("throw \'abc\'")')
  ee('Exe("throw \'def\'")')
--- 786,1062 ----
  :$put =string(pyeval('dl2'))
  :$put =string(pyeval('df(2)'))
  :"
! :" Test errors
! :fun F() dict
! :endfun
! :fun D()
  :endfun
  py << EOF
  def ee(expr, g=globals(), l=locals()):
      try:
          exec(expr, g, l)
      except:
!         cb.append(expr + ':' + repr(sys.exc_info()[:2]))
!     else:
!         cb.append(expr + ':NOT FAILED')
! d = vim.Dictionary()
! ned = vim.Dictionary(foo='bar', baz='abc')
! dl = vim.Dictionary(a=1)
! dl.locked = True
! l = vim.List()
! ll = vim.List('abc')
! ll.locked = True
! f = vim.Function('string')
! fd = vim.Function('F')
! fdel = vim.Function('D')
! vim.command('delfunction D')
! 
! def subexpr_test(expr, name, subexprs):
!     cb.append('>>> Testing %s using %s' % (name, expr))
!     for subexpr in subexprs:
!         ee(expr % subexpr)
!     cb.append('<<< Finished')
! 
! def stringtochars_test(expr):
!     return subexpr_test(expr, 'StringToChars', (
!         '1',       # Fail type checks
!         'u"\\0"',  # Fail PyString_AsStringAndSize(bytes, , NULL) check
!         '"\\0"',   # Fail PyString_AsStringAndSize(object, , NULL) check
!     ))
! 
! class Mapping(object):
!     def __init__(self, d):
!         self.d = d
! 
!     def __getitem__(self, key):
!         return self.d[key]
! 
!     def keys(self):
!         return self.d.keys()
! 
!     def items(self):
!         return self.d.items()
! 
! def convertfrompyobject_test(expr, recurse=True):
!     # pydict_to_tv
!     stringtochars_test(expr % '{%s : 1}')
!     if recurse:
!         convertfrompyobject_test(expr % '{"abc" : %s}', False)
!     # pymap_to_tv
!     stringtochars_test(expr % 'Mapping({%s : 1})')
!     if recurse:
!         convertfrompyobject_test(expr % 'Mapping({"abc" : %s})', False)
!     # pyseq_to_tv
!     iter_test(expr)
!     return subexpr_test(expr, 'ConvertFromPyObject', (
!         'None',                 # Not conversible
!         '{"": 1}',              # Empty key not allowed
!         'FailingMapping()',     #
!         'FailingMappingKey()',  #
!     ))
! 
! def convertfrompymapping_test(expr):
!     convertfrompyobject_test(expr)
!     return subexpr_test(expr, 'ConvertFromPyMapping', (
!         '[]',
!     ))
! 
! def iter_test(expr):
!     return subexpr_test(expr, '*Iter*', (
!         'FailingIter()',
!         'FailingIterNext()',
!     ))
! 
! class FailingTrue(object):
!     def __nonzero__(self):
!         raise NotImplementedError
! 
! class FailingIter(object):
!     def __iter__(self):
!         raise NotImplementedError
! 
! class FailingIterNext(object):
!     def __iter__(self):
!         return self
! 
!     def next(self):
!         raise NotImplementedError
! 
! class FailingMappingKey(object):
!     def __getitem__(self, item):
!         raise NotImplementedError
! 
!     def keys(self):
!         return list("abc")
! 
! class FailingMapping(object):
!     def __getitem__(self):
!         raise NotImplementedError
! 
!     def keys(self):
!         raise NotImplementedError
! 
! class FailingList(list):
!     def __getitem__(self, idx):
!         if i == 2:
!             raise NotImplementedError
!         else:
!             return super(FailingList, self).__getitem__(idx)
! 
! cb.append("> Output")
! cb.append(">> OutputSetattr")
! ee('del sys.stdout.softspace')
! ee('sys.stdout.softspace = []')
! ee('sys.stdout.attr = None')
! cb.append(">> OutputWrite")
! ee('sys.stdout.write(None)')
! cb.append(">> OutputWriteLines")
! ee('sys.stdout.writelines(None)')
! ee('sys.stdout.writelines([1])')
! iter_test('sys.stdout.writelines(%s)')
! cb.append("> VimCommand")
! ee('vim.command(1)')
! #! Not checked: vim->python exceptions translating: checked later
! cb.append("> VimToPython")
! #! Not checked: everything: needs errors in internal python functions
! cb.append("> VimEval")
! ee('vim.eval(1)')
! #! Not checked: everything: needs errors in internal python functions
! cb.append("> VimEvalPy")
! ee('vim.bindeval(1)')
! #! Not checked: vim->python exceptions translating: checked later
! cb.append("> VimStrwidth")
! ee('vim.strwidth(1)')
! cb.append("> Dictionary")
! cb.append(">> DictionaryConstructor")
! ee('vim.Dictionary("abc")')
! ##! Not checked: py_dict_alloc failure
! cb.append(">> DictionarySetattr")
! ee('del d.locked')
! ee('d.locked = FailingTrue()')
! ee('vim.vvars.locked = False')
! ee('d.scope = True')
! ee('d.xxx = True')
! cb.append(">> _DictionaryItem")
! ee('d.get("a", 2, 3)')
! stringtochars_test('d.get(%s)')
! ee('d.pop("a")')
! ee('dl.pop("a")')
! cb.append(">> DictionaryIterNext")
! ee('for i in ned: ned["a"] = 1')
! cb.append(">> DictionaryAssItem")
! ee('dl["b"] = 1')
! stringtochars_test('d[%s] = 1')
! convertfrompyobject_test('d["a"] = %s')
! cb.append(">> DictionaryUpdate")
! cb.append(">>> kwargs")
! cb.append(">>> iter")
! ee('d.update(FailingMapping())')
! ee('d.update([FailingIterNext()])')
! iter_test('d.update(%s)')
! convertfrompyobject_test('d.update(%s)')
! stringtochars_test('d.update(((%s, 0),))')
! convertfrompyobject_test('d.update((("a", %s),))')
! cb.append(">> DictionaryPopItem")
! ee('d.popitem(1, 2)')
! cb.append(">> DictionaryHasKey")
! ee('d.has_key()')
! cb.append("> List")
! cb.append(">> ListConstructor")
! ee('vim.List(1, 2)')
! ee('vim.List(a=1)')
! iter_test('vim.List(%s)')
! convertfrompyobject_test('vim.List([%s])')
! cb.append(">> ListItem")
! ee('l[1000]')
! cb.append(">> ListAssItem")
! ee('ll[1] = 2')
! ee('l[1000] = 3')
! cb.append(">> ListAssSlice")
! ee('ll[1:100] = "abc"')
! iter_test('l[:] = %s')
! convertfrompyobject_test('l[:] = [%s]')
! cb.append(">> ListConcatInPlace")
! iter_test('l.extend(%s)')
! convertfrompyobject_test('l.extend([%s])')
! cb.append(">> ListSetattr")
! ee('del l.locked')
! ee('l.locked = FailingTrue()')
! ee('l.xxx = True')
! cb.append("> Function")
! cb.append(">> FunctionConstructor")
! ee('vim.Function("123")')
! ee('vim.Function("xxx_non_existent_function_xxx")')
! ee('vim.Function("xxx#non#existent#function#xxx")')
! cb.append(">> FunctionCall")
! convertfrompyobject_test('f(%s)')
! convertfrompymapping_test('fd(self=%s)')
! cb.append("> TabPage")
! cb.append(">> TabPageAttr")
! ee('vim.current.tabpage.xxx')
! cb.append("> TabList")
! cb.append(">> TabListItem")
! ee('vim.tabpages[1000]')
! cb.append("> Window")
! cb.append(">> WindowAttr")
! ee('vim.current.window.xxx')
! cb.append(">> WindowSetattr")
! ee('vim.current.window.buffer = 0')
! ee('vim.current.window.cursor = (10000000000, 100000000)')
! ee('vim.current.window.cursor = True')
! ee('vim.current.window.height = "abc"')
! ee('vim.current.window.width  = "abc"')
! ee('vim.current.window.xxxxxx = True')
! cb.append("> WinList")
! cb.append(">> WinListItem")
! ee('vim.windows[1000]')
! cb.append("> Buffer")
! cb.append(">> StringToLine (indirect)")
! ee('vim.current.buffer[0] = "\\na"')
! cb.append(">> SetBufferLine (indirect)")
! ee('vim.current.buffer[0] = True')
! cb.append(">> SetBufferLines (indirect)")
! ee('vim.current.buffer[:] = True')
! ee('vim.current.buffer[:] = ["\\na", "bc"]')
! cb.append(">> InsertBufferLines (indirect)")
! ee('vim.current.buffer.append(None)')
! ee('vim.current.buffer.append(["\\na", "bc"])')
! ee('vim.current.buffer.append("\\nbc")')
! cb.append(">> RBItem")
! ee('vim.current.buffer[10000000000]')
! cb.append(">> RBAsItem")
! ee('vim.current.buffer[10000000000] = ""')
! cb.append(">> BufferAttr")
! ee('vim.current.buffer.xxx')
! cb.append(">> BufferSetattr")
! ee('vim.current.buffer.name = True')
! ee('vim.current.buffer.xxx = True')
! cb.append(">> BufferMark")
! ee('vim.current.buffer.mark(0)')
! ee('vim.current.buffer.mark("abc")')
! ee('vim.current.buffer.mark("!")')
! cb.append(">> BufferRange")
! ee('vim.current.buffer.range(1, 2, 3)')
! cb.append("> BufMap")
! cb.append(">> BufMapItem")
! ee('vim.buffers[None]')
! ee('vim.buffers[100000000]')
! cb.append("> Current")
! cb.append(">> CurrentGetattr")
! ee('vim.current.xxx')
! cb.append(">> CurrentSetattr")
! ee('vim.current.line = True')
! ee('vim.current.buffer = True')
! ee('vim.current.window = True')
! ee('vim.current.tabpage = True')
! ee('vim.current.xxx = True')
! EOF
! :"
! :" Test exceptions
! :fun Exe(e)
! :   execute a:e
! :endfun
! py << EOF
  Exe = vim.bindeval('function("Exe")')
  ee('vim.command("throw \'abc\'")')
  ee('Exe("throw \'def\'")')
*** ../vim-7.3.1065/src/testdir/test86.ok	2013-05-30 13:14:06.000000000 +0200
--- src/testdir/test86.ok	2013-05-30 13:25:22.000000000 +0200
***************
*** 429,437 ****
  ['a', 'b', 'c']
  [2, 2]
  [2, 2]
! (<class 'vim.error'>, error('abc',))
! (<class 'vim.error'>, error('def',))
! (<class 'vim.error'>, error('ghi',))
! (<class 'vim.error'>, error('Vim(echoerr):jkl',))
! (<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
! (<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
--- 429,1081 ----
  ['a', 'b', 'c']
  [2, 2]
  [2, 2]
! > Output
! >> OutputSetattr
! del sys.stdout.softspace:(<type 'exceptions.AttributeError'>, AttributeError("can't delete OutputObject attributes",))
! sys.stdout.softspace = []:(<type 'exceptions.TypeError'>, TypeError('softspace must be an integer',))
! sys.stdout.attr = None:(<type 'exceptions.AttributeError'>, AttributeError('invalid attribute',))
! >> OutputWrite
! sys.stdout.write(None):(<type 'exceptions.TypeError'>, TypeError('coercing to Unicode: need string or buffer, NoneType found',))
! >> OutputWriteLines
! sys.stdout.writelines(None):(<type 'exceptions.TypeError'>, TypeError("'NoneType' object is not iterable",))
! sys.stdout.writelines([1]):(<type 'exceptions.TypeError'>, TypeError('writelines() requires list of strings',))
! >>> Testing *Iter* using sys.stdout.writelines(%s)
! sys.stdout.writelines(FailingIter()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! sys.stdout.writelines(FailingIterNext()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! > VimCommand
! vim.command(1):(<type 'exceptions.TypeError'>, TypeError('must be string, not int',))
! > VimToPython
! > VimEval
! vim.eval(1):(<type 'exceptions.TypeError'>, TypeError('must be string, not int',))
! > VimEvalPy
! vim.bindeval(1):(<type 'exceptions.TypeError'>, TypeError('must be string, not int',))
! > VimStrwidth
! vim.strwidth(1):(<type 'exceptions.TypeError'>, TypeError('must be string, not int',))
! > Dictionary
! >> DictionaryConstructor
! vim.Dictionary("abc"):(<type 'exceptions.ValueError'>, ValueError('expected sequence element of size 2',))
! >> DictionarySetattr
! del d.locked:(<type 'exceptions.AttributeError'>, AttributeError('cannot delete vim.Dictionary attributes',))
! d.locked = FailingTrue():(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! vim.vvars.locked = False:(<type 'exceptions.TypeError'>, TypeError('cannot modify fixed dictionary',))
! d.scope = True:(<type 'exceptions.AttributeError'>, AttributeError('cannot set this attribute',))
! d.xxx = True:(<type 'exceptions.AttributeError'>, AttributeError('cannot set this attribute',))
! >> _DictionaryItem
! d.get("a", 2, 3):(<type 'exceptions.TypeError'>, TypeError('function takes at most 2 arguments (3 given)',))
! >>> Testing StringToChars using d.get(%s)
! d.get(1):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.get(u"\0"):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.get("\0"):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! d.pop("a"):(<type 'exceptions.KeyError'>, KeyError('a',))
! dl.pop("a"):(<class 'vim.error'>, error('dict is locked',))
! >> DictionaryIterNext
! for i in ned: ned["a"] = 1:(<type 'exceptions.RuntimeError'>, RuntimeError('hashtab changed during iteration',))
! >> DictionaryAssItem
! dl["b"] = 1:(<class 'vim.error'>, error('dict is locked',))
! >>> Testing StringToChars using d[%s] = 1
! d[1] = 1:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d[u"\0"] = 1:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["\0"] = 1:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d["a"] = {%s : 1}
! d["a"] = {1 : 1}:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d["a"] = {u"\0" : 1}:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["a"] = {"\0" : 1}:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d["a"] = {"abc" : {%s : 1}}
! d["a"] = {"abc" : {1 : 1}}:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d["a"] = {"abc" : {u"\0" : 1}}:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["a"] = {"abc" : {"\0" : 1}}:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d["a"] = {"abc" : Mapping({%s : 1})}
! d["a"] = {"abc" : Mapping({1 : 1})}:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d["a"] = {"abc" : Mapping({u"\0" : 1})}:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["a"] = {"abc" : Mapping({"\0" : 1})}:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using d["a"] = {"abc" : %s}
! d["a"] = {"abc" : FailingIter()}:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = {"abc" : FailingIterNext()}:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d["a"] = {"abc" : %s}
! d["a"] = {"abc" : None}:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = {"abc" : {"": 1}}:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d["a"] = {"abc" : FailingMapping()}:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d["a"] = {"abc" : FailingMappingKey()}:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using d["a"] = Mapping({%s : 1})
! d["a"] = Mapping({1 : 1}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d["a"] = Mapping({u"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["a"] = Mapping({"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d["a"] = Mapping({"abc" : {%s : 1}})
! d["a"] = Mapping({"abc" : {1 : 1}}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d["a"] = Mapping({"abc" : {u"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["a"] = Mapping({"abc" : {"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d["a"] = Mapping({"abc" : Mapping({%s : 1})})
! d["a"] = Mapping({"abc" : Mapping({1 : 1})}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d["a"] = Mapping({"abc" : Mapping({u"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["a"] = Mapping({"abc" : Mapping({"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using d["a"] = Mapping({"abc" : %s})
! d["a"] = Mapping({"abc" : FailingIter()}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = Mapping({"abc" : FailingIterNext()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d["a"] = Mapping({"abc" : %s})
! d["a"] = Mapping({"abc" : None}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = Mapping({"abc" : {"": 1}}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d["a"] = Mapping({"abc" : FailingMapping()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d["a"] = Mapping({"abc" : FailingMappingKey()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using d["a"] = %s
! d["a"] = FailingIter():(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = FailingIterNext():(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d["a"] = %s
! d["a"] = None:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = {"": 1}:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d["a"] = FailingMapping():(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d["a"] = FailingMappingKey():(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >> DictionaryUpdate
! >>> kwargs
! >>> iter
! d.update(FailingMapping()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update([FailingIterNext()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! >>> Testing *Iter* using d.update(%s)
! d.update(FailingIter()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update(FailingIterNext()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using d.update({%s : 1})
! d.update({1 : 1}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update({u"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update({"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d.update({"abc" : {%s : 1}})
! d.update({"abc" : {1 : 1}}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update({"abc" : {u"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update({"abc" : {"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d.update({"abc" : Mapping({%s : 1})})
! d.update({"abc" : Mapping({1 : 1})}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update({"abc" : Mapping({u"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update({"abc" : Mapping({"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using d.update({"abc" : %s})
! d.update({"abc" : FailingIter()}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update({"abc" : FailingIterNext()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d.update({"abc" : %s})
! d.update({"abc" : None}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update({"abc" : {"": 1}}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update({"abc" : FailingMapping()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update({"abc" : FailingMappingKey()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using d.update(Mapping({%s : 1}))
! d.update(Mapping({1 : 1})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update(Mapping({u"\0" : 1})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update(Mapping({"\0" : 1})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d.update(Mapping({"abc" : {%s : 1}}))
! d.update(Mapping({"abc" : {1 : 1}})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update(Mapping({"abc" : {u"\0" : 1}})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update(Mapping({"abc" : {"\0" : 1}})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d.update(Mapping({"abc" : Mapping({%s : 1})}))
! d.update(Mapping({"abc" : Mapping({1 : 1})})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update(Mapping({"abc" : Mapping({u"\0" : 1})})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update(Mapping({"abc" : Mapping({"\0" : 1})})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using d.update(Mapping({"abc" : %s}))
! d.update(Mapping({"abc" : FailingIter()})):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update(Mapping({"abc" : FailingIterNext()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d.update(Mapping({"abc" : %s}))
! d.update(Mapping({"abc" : None})):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update(Mapping({"abc" : {"": 1}})):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update(Mapping({"abc" : FailingMapping()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update(Mapping({"abc" : FailingMappingKey()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using d.update(%s)
! d.update(FailingIter()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update(FailingIterNext()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d.update(%s)
! d.update(None):(<type 'exceptions.TypeError'>, TypeError("'NoneType' object is not iterable",))
! d.update({"": 1}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update(FailingMapping()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update(FailingMappingKey()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using d.update(((%s, 0),))
! d.update(((1, 0),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update(((u"\0", 0),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("\0", 0),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d.update((("a", {%s : 1}),))
! d.update((("a", {1 : 1}),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update((("a", {u"\0" : 1}),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("a", {"\0" : 1}),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d.update((("a", {"abc" : {%s : 1}}),))
! d.update((("a", {"abc" : {1 : 1}}),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update((("a", {"abc" : {u"\0" : 1}}),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("a", {"abc" : {"\0" : 1}}),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d.update((("a", {"abc" : Mapping({%s : 1})}),))
! d.update((("a", {"abc" : Mapping({1 : 1})}),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update((("a", {"abc" : Mapping({u"\0" : 1})}),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("a", {"abc" : Mapping({"\0" : 1})}),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using d.update((("a", {"abc" : %s}),))
! d.update((("a", {"abc" : FailingIter()}),)):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", {"abc" : FailingIterNext()}),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d.update((("a", {"abc" : %s}),))
! d.update((("a", {"abc" : None}),)):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", {"abc" : {"": 1}}),)):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update((("a", {"abc" : FailingMapping()}),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update((("a", {"abc" : FailingMappingKey()}),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using d.update((("a", Mapping({%s : 1})),))
! d.update((("a", Mapping({1 : 1})),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update((("a", Mapping({u"\0" : 1})),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("a", Mapping({"\0" : 1})),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d.update((("a", Mapping({"abc" : {%s : 1}})),))
! d.update((("a", Mapping({"abc" : {1 : 1}})),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update((("a", Mapping({"abc" : {u"\0" : 1}})),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("a", Mapping({"abc" : {"\0" : 1}})),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using d.update((("a", Mapping({"abc" : Mapping({%s : 1})})),))
! d.update((("a", Mapping({"abc" : Mapping({1 : 1})})),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update((("a", Mapping({"abc" : Mapping({u"\0" : 1})})),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("a", Mapping({"abc" : Mapping({"\0" : 1})})),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using d.update((("a", Mapping({"abc" : %s})),))
! d.update((("a", Mapping({"abc" : FailingIter()})),)):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", Mapping({"abc" : FailingIterNext()})),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d.update((("a", Mapping({"abc" : %s})),))
! d.update((("a", Mapping({"abc" : None})),)):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", Mapping({"abc" : {"": 1}})),)):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update((("a", Mapping({"abc" : FailingMapping()})),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update((("a", Mapping({"abc" : FailingMappingKey()})),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using d.update((("a", %s),))
! d.update((("a", FailingIter()),)):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", FailingIterNext()),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d.update((("a", %s),))
! d.update((("a", None),)):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", {"": 1}),)):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update((("a", FailingMapping()),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update((("a", FailingMappingKey()),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >> DictionaryPopItem
! d.popitem(1, 2):(<type 'exceptions.TypeError'>, TypeError('function takes exactly 1 argument (2 given)',))
! >> DictionaryHasKey
! d.has_key():(<type 'exceptions.TypeError'>, TypeError('function takes exactly 1 argument (0 given)',))
! > List
! >> ListConstructor
! vim.List(1, 2):(<type 'exceptions.TypeError'>, TypeError('function takes at most 1 argument (2 given)',))
! vim.List(a=1):(<type 'exceptions.TypeError'>, TypeError('list constructor does not accept keyword arguments',))
! >>> Testing *Iter* using vim.List(%s)
! vim.List(FailingIter()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! vim.List(FailingIterNext()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using vim.List([{%s : 1}])
! vim.List([{1 : 1}]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.List([{u"\0" : 1}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! vim.List([{"\0" : 1}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using vim.List([{"abc" : {%s : 1}}])
! vim.List([{"abc" : {1 : 1}}]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.List([{"abc" : {u"\0" : 1}}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! vim.List([{"abc" : {"\0" : 1}}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using vim.List([{"abc" : Mapping({%s : 1})}])
! vim.List([{"abc" : Mapping({1 : 1})}]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.List([{"abc" : Mapping({u"\0" : 1})}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! vim.List([{"abc" : Mapping({"\0" : 1})}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using vim.List([{"abc" : %s}])
! vim.List([{"abc" : FailingIter()}]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([{"abc" : FailingIterNext()}]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using vim.List([{"abc" : %s}])
! vim.List([{"abc" : None}]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([{"abc" : {"": 1}}]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! vim.List([{"abc" : FailingMapping()}]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! vim.List([{"abc" : FailingMappingKey()}]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using vim.List([Mapping({%s : 1})])
! vim.List([Mapping({1 : 1})]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.List([Mapping({u"\0" : 1})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! vim.List([Mapping({"\0" : 1})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using vim.List([Mapping({"abc" : {%s : 1}})])
! vim.List([Mapping({"abc" : {1 : 1}})]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.List([Mapping({"abc" : {u"\0" : 1}})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! vim.List([Mapping({"abc" : {"\0" : 1}})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using vim.List([Mapping({"abc" : Mapping({%s : 1})})])
! vim.List([Mapping({"abc" : Mapping({1 : 1})})]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.List([Mapping({"abc" : Mapping({u"\0" : 1})})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! vim.List([Mapping({"abc" : Mapping({"\0" : 1})})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using vim.List([Mapping({"abc" : %s})])
! vim.List([Mapping({"abc" : FailingIter()})]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([Mapping({"abc" : FailingIterNext()})]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using vim.List([Mapping({"abc" : %s})])
! vim.List([Mapping({"abc" : None})]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([Mapping({"abc" : {"": 1}})]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! vim.List([Mapping({"abc" : FailingMapping()})]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! vim.List([Mapping({"abc" : FailingMappingKey()})]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using vim.List([%s])
! vim.List([FailingIter()]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([FailingIterNext()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using vim.List([%s])
! vim.List([None]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([{"": 1}]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! vim.List([FailingMapping()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! vim.List([FailingMappingKey()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >> ListItem
! l[1000]:(<type 'exceptions.IndexError'>, IndexError('list index out of range',))
! >> ListAssItem
! ll[1] = 2:(<class 'vim.error'>, error('list is locked',))
! l[1000] = 3:(<type 'exceptions.IndexError'>, IndexError('list index out of range',))
! >> ListAssSlice
! ll[1:100] = "abc":(<class 'vim.error'>, error('list is locked',))
! >>> Testing *Iter* using l[:] = %s
! l[:] = FailingIter():(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l[:] = FailingIterNext():(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using l[:] = [{%s : 1}]
! l[:] = [{1 : 1}]:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l[:] = [{u"\0" : 1}]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l[:] = [{"\0" : 1}]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using l[:] = [{"abc" : {%s : 1}}]
! l[:] = [{"abc" : {1 : 1}}]:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l[:] = [{"abc" : {u"\0" : 1}}]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l[:] = [{"abc" : {"\0" : 1}}]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using l[:] = [{"abc" : Mapping({%s : 1})}]
! l[:] = [{"abc" : Mapping({1 : 1})}]:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l[:] = [{"abc" : Mapping({u"\0" : 1})}]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l[:] = [{"abc" : Mapping({"\0" : 1})}]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using l[:] = [{"abc" : %s}]
! l[:] = [{"abc" : FailingIter()}]:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [{"abc" : FailingIterNext()}]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using l[:] = [{"abc" : %s}]
! l[:] = [{"abc" : None}]:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [{"abc" : {"": 1}}]:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l[:] = [{"abc" : FailingMapping()}]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l[:] = [{"abc" : FailingMappingKey()}]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using l[:] = [Mapping({%s : 1})]
! l[:] = [Mapping({1 : 1})]:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l[:] = [Mapping({u"\0" : 1})]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l[:] = [Mapping({"\0" : 1})]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using l[:] = [Mapping({"abc" : {%s : 1}})]
! l[:] = [Mapping({"abc" : {1 : 1}})]:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l[:] = [Mapping({"abc" : {u"\0" : 1}})]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l[:] = [Mapping({"abc" : {"\0" : 1}})]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using l[:] = [Mapping({"abc" : Mapping({%s : 1})})]
! l[:] = [Mapping({"abc" : Mapping({1 : 1})})]:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l[:] = [Mapping({"abc" : Mapping({u"\0" : 1})})]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l[:] = [Mapping({"abc" : Mapping({"\0" : 1})})]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using l[:] = [Mapping({"abc" : %s})]
! l[:] = [Mapping({"abc" : FailingIter()})]:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [Mapping({"abc" : FailingIterNext()})]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using l[:] = [Mapping({"abc" : %s})]
! l[:] = [Mapping({"abc" : None})]:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [Mapping({"abc" : {"": 1}})]:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l[:] = [Mapping({"abc" : FailingMapping()})]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l[:] = [Mapping({"abc" : FailingMappingKey()})]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using l[:] = [%s]
! l[:] = [FailingIter()]:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [FailingIterNext()]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using l[:] = [%s]
! l[:] = [None]:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [{"": 1}]:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l[:] = [FailingMapping()]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l[:] = [FailingMappingKey()]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >> ListConcatInPlace
! >>> Testing *Iter* using l.extend(%s)
! l.extend(FailingIter()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l.extend(FailingIterNext()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using l.extend([{%s : 1}])
! l.extend([{1 : 1}]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l.extend([{u"\0" : 1}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l.extend([{"\0" : 1}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using l.extend([{"abc" : {%s : 1}}])
! l.extend([{"abc" : {1 : 1}}]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l.extend([{"abc" : {u"\0" : 1}}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l.extend([{"abc" : {"\0" : 1}}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using l.extend([{"abc" : Mapping({%s : 1})}])
! l.extend([{"abc" : Mapping({1 : 1})}]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l.extend([{"abc" : Mapping({u"\0" : 1})}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l.extend([{"abc" : Mapping({"\0" : 1})}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using l.extend([{"abc" : %s}])
! l.extend([{"abc" : FailingIter()}]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([{"abc" : FailingIterNext()}]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using l.extend([{"abc" : %s}])
! l.extend([{"abc" : None}]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([{"abc" : {"": 1}}]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l.extend([{"abc" : FailingMapping()}]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l.extend([{"abc" : FailingMappingKey()}]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using l.extend([Mapping({%s : 1})])
! l.extend([Mapping({1 : 1})]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l.extend([Mapping({u"\0" : 1})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l.extend([Mapping({"\0" : 1})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using l.extend([Mapping({"abc" : {%s : 1}})])
! l.extend([Mapping({"abc" : {1 : 1}})]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l.extend([Mapping({"abc" : {u"\0" : 1}})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l.extend([Mapping({"abc" : {"\0" : 1}})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using l.extend([Mapping({"abc" : Mapping({%s : 1})})])
! l.extend([Mapping({"abc" : Mapping({1 : 1})})]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l.extend([Mapping({"abc" : Mapping({u"\0" : 1})})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l.extend([Mapping({"abc" : Mapping({"\0" : 1})})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using l.extend([Mapping({"abc" : %s})])
! l.extend([Mapping({"abc" : FailingIter()})]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([Mapping({"abc" : FailingIterNext()})]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using l.extend([Mapping({"abc" : %s})])
! l.extend([Mapping({"abc" : None})]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([Mapping({"abc" : {"": 1}})]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l.extend([Mapping({"abc" : FailingMapping()})]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l.extend([Mapping({"abc" : FailingMappingKey()})]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using l.extend([%s])
! l.extend([FailingIter()]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([FailingIterNext()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using l.extend([%s])
! l.extend([None]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([{"": 1}]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l.extend([FailingMapping()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l.extend([FailingMappingKey()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >> ListSetattr
! del l.locked:(<type 'exceptions.AttributeError'>, AttributeError('cannot delete vim.List attributes',))
! l.locked = FailingTrue():(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l.xxx = True:(<type 'exceptions.AttributeError'>, AttributeError('cannot set this attribute',))
! > Function
! >> FunctionConstructor
! vim.Function("123"):(<type 'exceptions.ValueError'>, ValueError('unnamed function does not exist',))
! vim.Function("xxx_non_existent_function_xxx"):(<type 'exceptions.ValueError'>, ValueError('function does not exist',))
! vim.Function("xxx#non#existent#function#xxx"):(<type 'exceptions.ValueError'>, ValueError('function does not exist',))
! >> FunctionCall
! >>> Testing StringToChars using f({%s : 1})
! f({1 : 1}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! f({u"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! f({"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using f({"abc" : {%s : 1}})
! f({"abc" : {1 : 1}}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! f({"abc" : {u"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! f({"abc" : {"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using f({"abc" : Mapping({%s : 1})})
! f({"abc" : Mapping({1 : 1})}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! f({"abc" : Mapping({u"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! f({"abc" : Mapping({"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using f({"abc" : %s})
! f({"abc" : FailingIter()}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! f({"abc" : FailingIterNext()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using f({"abc" : %s})
! f({"abc" : None}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! f({"abc" : {"": 1}}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! f({"abc" : FailingMapping()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! f({"abc" : FailingMappingKey()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using f(Mapping({%s : 1}))
! f(Mapping({1 : 1})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! f(Mapping({u"\0" : 1})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! f(Mapping({"\0" : 1})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using f(Mapping({"abc" : {%s : 1}}))
! f(Mapping({"abc" : {1 : 1}})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! f(Mapping({"abc" : {u"\0" : 1}})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! f(Mapping({"abc" : {"\0" : 1}})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using f(Mapping({"abc" : Mapping({%s : 1})}))
! f(Mapping({"abc" : Mapping({1 : 1})})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! f(Mapping({"abc" : Mapping({u"\0" : 1})})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! f(Mapping({"abc" : Mapping({"\0" : 1})})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using f(Mapping({"abc" : %s}))
! f(Mapping({"abc" : FailingIter()})):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! f(Mapping({"abc" : FailingIterNext()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using f(Mapping({"abc" : %s}))
! f(Mapping({"abc" : None})):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! f(Mapping({"abc" : {"": 1}})):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! f(Mapping({"abc" : FailingMapping()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! f(Mapping({"abc" : FailingMappingKey()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using f(%s)
! f(FailingIter()):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! f(FailingIterNext()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using f(%s)
! f(None):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! f({"": 1}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! f(FailingMapping()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! f(FailingMappingKey()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using fd(self={%s : 1})
! fd(self={1 : 1}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! fd(self={u"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! fd(self={"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using fd(self={"abc" : {%s : 1}})
! fd(self={"abc" : {1 : 1}}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! fd(self={"abc" : {u"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! fd(self={"abc" : {"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using fd(self={"abc" : Mapping({%s : 1})})
! fd(self={"abc" : Mapping({1 : 1})}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! fd(self={"abc" : Mapping({u"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! fd(self={"abc" : Mapping({"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using fd(self={"abc" : %s})
! fd(self={"abc" : FailingIter()}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! fd(self={"abc" : FailingIterNext()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using fd(self={"abc" : %s})
! fd(self={"abc" : None}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! fd(self={"abc" : {"": 1}}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! fd(self={"abc" : FailingMapping()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! fd(self={"abc" : FailingMappingKey()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using fd(self=Mapping({%s : 1}))
! fd(self=Mapping({1 : 1})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! fd(self=Mapping({u"\0" : 1})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! fd(self=Mapping({"\0" : 1})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using fd(self=Mapping({"abc" : {%s : 1}}))
! fd(self=Mapping({"abc" : {1 : 1}})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! fd(self=Mapping({"abc" : {u"\0" : 1}})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! fd(self=Mapping({"abc" : {"\0" : 1}})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing StringToChars using fd(self=Mapping({"abc" : Mapping({%s : 1})}))
! fd(self=Mapping({"abc" : Mapping({1 : 1})})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! fd(self=Mapping({"abc" : Mapping({u"\0" : 1})})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! fd(self=Mapping({"abc" : Mapping({"\0" : 1})})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! <<< Finished
! >>> Testing *Iter* using fd(self=Mapping({"abc" : %s}))
! fd(self=Mapping({"abc" : FailingIter()})):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! fd(self=Mapping({"abc" : FailingIterNext()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using fd(self=Mapping({"abc" : %s}))
! fd(self=Mapping({"abc" : None})):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! fd(self=Mapping({"abc" : {"": 1}})):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! fd(self=Mapping({"abc" : FailingMapping()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! fd(self=Mapping({"abc" : FailingMappingKey()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using fd(self=%s)
! fd(self=FailingIter()):(<type 'exceptions.TypeError'>, TypeError('unable to convert object to vim dictionary',))
! fd(self=FailingIterNext()):(<type 'exceptions.TypeError'>, TypeError('unable to convert object to vim dictionary',))
! <<< Finished
! >>> Testing ConvertFromPyObject using fd(self=%s)
! fd(self=None):(<type 'exceptions.TypeError'>, TypeError('unable to convert object to vim dictionary',))
! fd(self={"": 1}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! fd(self=FailingMapping()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! fd(self=FailingMappingKey()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyMapping using fd(self=%s)
! fd(self=[]):(<type 'exceptions.TypeError'>, TypeError('unable to convert object to vim dictionary',))
! <<< Finished
! > TabPage
! >> TabPageAttr
! vim.current.tabpage.xxx:(<type 'exceptions.AttributeError'>, AttributeError('xxx',))
! > TabList
! >> TabListItem
! vim.tabpages[1000]:(<type 'exceptions.IndexError'>, IndexError('no such tab page',))
! > Window
! >> WindowAttr
! vim.current.window.xxx:(<type 'exceptions.AttributeError'>, AttributeError('xxx',))
! >> WindowSetattr
! vim.current.window.buffer = 0:(<type 'exceptions.TypeError'>, TypeError('readonly attribute',))
! vim.current.window.cursor = (10000000000, 100000000):(<class 'vim.error'>, error('cursor position outside buffer',))
! vim.current.window.cursor = True:(<type 'exceptions.TypeError'>, TypeError('argument must be 2-item sequence, not bool',))
! vim.current.window.height = "abc":(<type 'exceptions.TypeError'>, TypeError('an integer is required',))
! vim.current.window.width  = "abc":(<type 'exceptions.TypeError'>, TypeError('an integer is required',))
! vim.current.window.xxxxxx = True:(<type 'exceptions.AttributeError'>, AttributeError('xxxxxx',))
! > WinList
! >> WinListItem
! vim.windows[1000]:(<type 'exceptions.IndexError'>, IndexError('no such window',))
! > Buffer
! >> StringToLine (indirect)
! vim.current.buffer[0] = "\na":(<class 'vim.error'>, error('string cannot contain newlines',))
! >> SetBufferLine (indirect)
! vim.current.buffer[0] = True:(<type 'exceptions.TypeError'>, TypeError('bad argument type for built-in operation',))
! >> SetBufferLines (indirect)
! vim.current.buffer[:] = True:(<type 'exceptions.TypeError'>, TypeError('bad argument type for built-in operation',))
! vim.current.buffer[:] = ["\na", "bc"]:(<class 'vim.error'>, error('string cannot contain newlines',))
! >> InsertBufferLines (indirect)
! vim.current.buffer.append(None):(<type 'exceptions.TypeError'>, TypeError('bad argument type for built-in operation',))
! vim.current.buffer.append(["\na", "bc"]):(<class 'vim.error'>, error('string cannot contain newlines',))
! vim.current.buffer.append("\nbc"):(<class 'vim.error'>, error('string cannot contain newlines',))
! >> RBItem
! vim.current.buffer[10000000000]:(<type 'exceptions.IndexError'>, IndexError('line number out of range',))
! >> RBAsItem
! vim.current.buffer[10000000000] = "":(<type 'exceptions.IndexError'>, IndexError('line number out of range',))
! >> BufferAttr
! vim.current.buffer.xxx:(<type 'exceptions.AttributeError'>, AttributeError('xxx',))
! >> BufferSetattr
! vim.current.buffer.name = True:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.current.buffer.xxx = True:(<type 'exceptions.AttributeError'>, AttributeError('xxx',))
! >> BufferMark
! vim.current.buffer.mark(0):(<type 'exceptions.TypeError'>, TypeError('must be string, not int',))
! vim.current.buffer.mark("abc"):(<type 'exceptions.ValueError'>, ValueError('mark name must be a single character',))
! vim.current.buffer.mark("!"):(<class 'vim.error'>, error('invalid mark name',))
! >> BufferRange
! vim.current.buffer.range(1, 2, 3):(<type 'exceptions.TypeError'>, TypeError('function takes exactly 2 arguments (3 given)',))
! > BufMap
! >> BufMapItem
! vim.buffers[None]:(<type 'exceptions.TypeError'>, TypeError('key must be integer',))
! vim.buffers[100000000]:(<type 'exceptions.KeyError'>, KeyError(100000000,))
! > Current
! >> CurrentGetattr
! vim.current.xxx:(<type 'exceptions.AttributeError'>, AttributeError('xxx',))
! >> CurrentSetattr
! vim.current.line = True:(<type 'exceptions.TypeError'>, TypeError('bad argument type for built-in operation',))
! vim.current.buffer = True:(<type 'exceptions.TypeError'>, TypeError('expected vim.Buffer object',))
! vim.current.window = True:(<type 'exceptions.TypeError'>, TypeError('expected vim.Window object',))
! vim.current.tabpage = True:(<type 'exceptions.TypeError'>, TypeError('expected vim.TabPage object',))
! vim.current.xxx = True:(<type 'exceptions.AttributeError'>, AttributeError('xxx',))
! vim.command("throw 'abc'"):(<class 'vim.error'>, error('abc',))
! Exe("throw 'def'"):(<class 'vim.error'>, error('def',))
! vim.eval("Exe('throw ''ghi''')"):(<class 'vim.error'>, error('ghi',))
! vim.eval("Exe('echoerr ''jkl''')"):(<class 'vim.error'>, error('Vim(echoerr):jkl',))
! vim.eval("Exe('xxx_non_existent_command_xxx')"):(<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
! vim.bindeval("Exe('xxx_non_existent_command_xxx')"):(<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
*** ../vim-7.3.1065/src/testdir/test87.in	2013-05-30 13:14:06.000000000 +0200
--- src/testdir/test87.in	2013-05-30 13:25:22.000000000 +0200
***************
*** 746,761 ****
  :$put =string(py3eval('dl2'))
  :$put =string(py3eval('df(2)'))
  :"
! :" Test exceptions
! :fun Exe(e)
! :   execute a:e
  :endfun
  py3 << EOF
  def ee(expr, g=globals(), l=locals()):
      try:
!         exec(expr, g, l)
      except Exception as e:
!         cb.append(repr((e.__class__, e)))
  Exe = vim.bindeval('function("Exe")')
  ee('vim.command("throw \'abc\'")')
  ee('Exe("throw \'def\'")')
--- 746,1026 ----
  :$put =string(py3eval('dl2'))
  :$put =string(py3eval('df(2)'))
  :"
! :" Test errors
! :fun F() dict
! :endfun
! :fun D()
  :endfun
  py3 << EOF
  def ee(expr, g=globals(), l=locals()):
      try:
!         try:
!             exec(expr, g, l)
!         except Exception as e:
!             cb.append(expr + ':' + repr((e.__class__, e)))
!         else:
!             cb.append(expr + ':NOT FAILED')
      except Exception as e:
!         cb.append(expr + '::' + repr((e.__class__, e)))
! 
! d = vim.Dictionary()
! ned = vim.Dictionary(foo='bar', baz='abc')
! dl = vim.Dictionary(a=1)
! dl.locked = True
! l = vim.List()
! ll = vim.List('abc')
! ll.locked = True
! f = vim.Function('string')
! fd = vim.Function('F')
! fdel = vim.Function('D')
! vim.command('delfunction D')
! 
! def subexpr_test(expr, name, subexprs):
!     cb.append('>>> Testing %s using %s' % (name, expr))
!     for subexpr in subexprs:
!         ee(expr % subexpr)
!     cb.append('<<< Finished')
! 
! def stringtochars_test(expr):
!     return subexpr_test(expr, 'StringToChars', (
!         '1',       # Fail type checks
!         'u"\\0"',  # Fail PyString_AsStringAndSize(bytes, , NULL) check
!         '"\\0"',   # Fail PyString_AsStringAndSize(object, , NULL) check
!     ))
! 
! class Mapping(object):
!     def __init__(self, d):
!         self.d = d
! 
!     def __getitem__(self, key):
!         return self.d[key]
! 
!     def keys(self):
!         return self.d.keys()
! 
!     def items(self):
!         return self.d.items()
! 
! def convertfrompyobject_test(expr, recurse=True):
!     # pydict_to_tv
!     stringtochars_test(expr % '{%s : 1}')
!     if recurse:
!         convertfrompyobject_test(expr % '{"abc" : %s}', False)
!     # pymap_to_tv
!     stringtochars_test(expr % 'Mapping({%s : 1})')
!     if recurse:
!         convertfrompyobject_test(expr % 'Mapping({"abc" : %s})', False)
!     # pyseq_to_tv
!     iter_test(expr)
!     return subexpr_test(expr, 'ConvertFromPyObject', (
!         'None',                 # Not conversible
!         '{"": 1}',              # Empty key not allowed
!         'FailingMapping()',     #
!         'FailingMappingKey()',  #
!     ))
! 
! def convertfrompymapping_test(expr):
!     convertfrompyobject_test(expr)
!     return subexpr_test(expr, 'ConvertFromPyMapping', (
!         '[]',
!     ))
! 
! def iter_test(expr):
!     return subexpr_test(expr, '*Iter*', (
!         'FailingIter()',
!         'FailingIterNext()',
!     ))
! 
! class FailingTrue(object):
!     def __bool__(self):
!         raise NotImplementedError
! 
! class FailingIter(object):
!     def __iter__(self):
!         raise NotImplementedError
! 
! class FailingIterNext(object):
!     def __iter__(self):
!         return self
! 
!     def __next__(self):
!         raise NotImplementedError
! 
! class FailingMappingKey(object):
!     def __getitem__(self, item):
!         raise NotImplementedError
! 
!     def keys(self):
!         return list("abc")
! 
! class FailingMapping(object):
!     def __getitem__(self):
!         raise NotImplementedError
! 
!     def keys(self):
!         raise NotImplementedError
! 
! class FailingList(list):
!     def __getitem__(self, idx):
!         if i == 2:
!             raise NotImplementedError
!         else:
!             return super(FailingList, self).__getitem__(idx)
! 
! cb.append("> Output")
! cb.append(">> OutputSetattr")
! ee('del sys.stdout.softspace')
! ee('sys.stdout.softspace = []')
! ee('sys.stdout.attr = None')
! cb.append(">> OutputWrite")
! ee('sys.stdout.write(None)')
! cb.append(">> OutputWriteLines")
! ee('sys.stdout.writelines(None)')
! ee('sys.stdout.writelines([1])')
! iter_test('sys.stdout.writelines(%s)')
! cb.append("> VimCommand")
! ee('vim.command(1)')
! #! Not checked: vim->python exceptions translating: checked later
! cb.append("> VimToPython")
! #! Not checked: everything: needs errors in internal python functions
! cb.append("> VimEval")
! ee('vim.eval(1)')
! #! Not checked: everything: needs errors in internal python functions
! cb.append("> VimEvalPy")
! ee('vim.bindeval(1)')
! #! Not checked: vim->python exceptions translating: checked later
! cb.append("> VimStrwidth")
! ee('vim.strwidth(1)')
! cb.append("> Dictionary")
! cb.append(">> DictionaryConstructor")
! ee('vim.Dictionary("abc")')
! ##! Not checked: py_dict_alloc failure
! cb.append(">> DictionarySetattr")
! ee('del d.locked')
! ee('d.locked = FailingTrue()')
! ee('vim.vvars.locked = False')
! ee('d.scope = True')
! ee('d.xxx = True')
! cb.append(">> _DictionaryItem")
! ee('d.get("a", 2, 3)')
! stringtochars_test('d.get(%s)')
! ee('d.pop("a")')
! ee('dl.pop("a")')
! cb.append(">> DictionaryIterNext")
! ee('for i in ned: ned["a"] = 1')
! cb.append(">> DictionaryAssItem")
! ee('dl["b"] = 1')
! stringtochars_test('d[%s] = 1')
! convertfrompyobject_test('d["a"] = %s')
! cb.append(">> DictionaryUpdate")
! cb.append(">>> kwargs")
! cb.append(">>> iter")
! ee('d.update(FailingMapping())')
! ee('d.update([FailingIterNext()])')
! iter_test('d.update(%s)')
! convertfrompyobject_test('d.update(%s)')
! stringtochars_test('d.update(((%s, 0),))')
! convertfrompyobject_test('d.update((("a", %s),))')
! cb.append(">> DictionaryPopItem")
! ee('d.popitem(1, 2)')
! cb.append(">> DictionaryHasKey")
! ee('d.has_key()')
! cb.append("> List")
! cb.append(">> ListConstructor")
! ee('vim.List(1, 2)')
! ee('vim.List(a=1)')
! iter_test('vim.List(%s)')
! convertfrompyobject_test('vim.List([%s])')
! cb.append(">> ListItem")
! ee('l[1000]')
! cb.append(">> ListAssItem")
! ee('ll[1] = 2')
! ee('l[1000] = 3')
! cb.append(">> ListAssSlice")
! ee('ll[1:100] = "abc"')
! iter_test('l[:] = %s')
! convertfrompyobject_test('l[:] = [%s]')
! cb.append(">> ListConcatInPlace")
! iter_test('l.extend(%s)')
! convertfrompyobject_test('l.extend([%s])')
! cb.append(">> ListSetattr")
! ee('del l.locked')
! ee('l.locked = FailingTrue()')
! ee('l.xxx = True')
! cb.append("> Function")
! cb.append(">> FunctionConstructor")
! ee('vim.Function("123")')
! ee('vim.Function("xxx_non_existent_function_xxx")')
! ee('vim.Function("xxx#non#existent#function#xxx")')
! cb.append(">> FunctionCall")
! convertfrompyobject_test('f(%s)')
! convertfrompymapping_test('fd(self=%s)')
! cb.append("> TabPage")
! cb.append(">> TabPageAttr")
! ee('vim.current.tabpage.xxx')
! cb.append("> TabList")
! cb.append(">> TabListItem")
! ee('vim.tabpages[1000]')
! cb.append("> Window")
! cb.append(">> WindowAttr")
! ee('vim.current.window.xxx')
! cb.append(">> WindowSetattr")
! ee('vim.current.window.buffer = 0')
! ee('vim.current.window.cursor = (10000000000, 100000000)')
! ee('vim.current.window.cursor = True')
! ee('vim.current.window.height = "abc"')
! ee('vim.current.window.width  = "abc"')
! ee('vim.current.window.xxxxxx = True')
! cb.append("> WinList")
! cb.append(">> WinListItem")
! ee('vim.windows[1000]')
! cb.append("> Buffer")
! cb.append(">> StringToLine (indirect)")
! ee('vim.current.buffer[0] = "\\na"')
! cb.append(">> SetBufferLine (indirect)")
! ee('vim.current.buffer[0] = True')
! cb.append(">> SetBufferLines (indirect)")
! ee('vim.current.buffer[:] = True')
! ee('vim.current.buffer[:] = ["\\na", "bc"]')
! cb.append(">> InsertBufferLines (indirect)")
! ee('vim.current.buffer.append(None)')
! ee('vim.current.buffer.append(["\\na", "bc"])')
! ee('vim.current.buffer.append("\\nbc")')
! cb.append(">> RBItem")
! ee('vim.current.buffer[10000000000]')
! cb.append(">> RBAsItem")
! ee('vim.current.buffer[10000000000] = ""')
! cb.append(">> BufferAttr")
! ee('vim.current.buffer.xxx')
! cb.append(">> BufferSetattr")
! ee('vim.current.buffer.name = True')
! ee('vim.current.buffer.xxx = True')
! cb.append(">> BufferMark")
! ee('vim.current.buffer.mark(0)')
! ee('vim.current.buffer.mark("abc")')
! ee('vim.current.buffer.mark("!")')
! cb.append(">> BufferRange")
! ee('vim.current.buffer.range(1, 2, 3)')
! cb.append("> BufMap")
! cb.append(">> BufMapItem")
! ee('vim.buffers[None]')
! ee('vim.buffers[100000000]')
! cb.append("> Current")
! cb.append(">> CurrentGetattr")
! ee('vim.current.xxx')
! cb.append(">> CurrentSetattr")
! ee('vim.current.line = True')
! ee('vim.current.buffer = True')
! ee('vim.current.window = True')
! ee('vim.current.tabpage = True')
! ee('vim.current.xxx = True')
! EOF
! :"
! :" Test exceptions
! :fun Exe(e)
! :   execute a:e
! :endfun
! py3 << EOF
  Exe = vim.bindeval('function("Exe")')
  ee('vim.command("throw \'abc\'")')
  ee('Exe("throw \'def\'")')
*** ../vim-7.3.1065/src/testdir/test87.ok	2013-05-30 13:14:06.000000000 +0200
--- src/testdir/test87.ok	2013-05-30 13:25:22.000000000 +0200
***************
*** 418,426 ****
  ['a', 'b', 'c']
  [2, 2]
  [2, 2]
! (<class 'vim.error'>, error('abc',))
! (<class 'vim.error'>, error('def',))
! (<class 'vim.error'>, error('ghi',))
! (<class 'vim.error'>, error('Vim(echoerr):jkl',))
! (<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
! (<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
--- 418,1070 ----
  ['a', 'b', 'c']
  [2, 2]
  [2, 2]
! > Output
! >> OutputSetattr
! del sys.stdout.softspace:(<class 'AttributeError'>, AttributeError("can't delete OutputObject attributes",))
! sys.stdout.softspace = []:(<class 'TypeError'>, TypeError('softspace must be an integer',))
! sys.stdout.attr = None:(<class 'AttributeError'>, AttributeError('invalid attribute',))
! >> OutputWrite
! sys.stdout.write(None):(<class 'TypeError'>, TypeError("Can't convert 'NoneType' object to str implicitly",))
! >> OutputWriteLines
! sys.stdout.writelines(None):(<class 'TypeError'>, TypeError("'NoneType' object is not iterable",))
! sys.stdout.writelines([1]):(<class 'TypeError'>, TypeError('writelines() requires list of strings',))
! >>> Testing *Iter* using sys.stdout.writelines(%s)
! sys.stdout.writelines(FailingIter()):(<class 'NotImplementedError'>, NotImplementedError())
! sys.stdout.writelines(FailingIterNext()):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! > VimCommand
! vim.command(1):(<class 'TypeError'>, TypeError('must be str, not int',))
! > VimToPython
! > VimEval
! vim.eval(1):(<class 'TypeError'>, TypeError('must be str, not int',))
! > VimEvalPy
! vim.bindeval(1):(<class 'TypeError'>, TypeError('must be str, not int',))
! > VimStrwidth
! vim.strwidth(1):(<class 'TypeError'>, TypeError('must be str, not int',))
! > Dictionary
! >> DictionaryConstructor
! vim.Dictionary("abc"):(<class 'ValueError'>, ValueError('expected sequence element of size 2',))
! >> DictionarySetattr
! del d.locked:(<class 'AttributeError'>, AttributeError('cannot delete vim.Dictionary attributes',))
! d.locked = FailingTrue():(<class 'NotImplementedError'>, NotImplementedError())
! vim.vvars.locked = False:(<class 'TypeError'>, TypeError('cannot modify fixed dictionary',))
! d.scope = True:(<class 'AttributeError'>, AttributeError('cannot set this attribute',))
! d.xxx = True:(<class 'AttributeError'>, AttributeError('cannot set this attribute',))
! >> _DictionaryItem
! d.get("a", 2, 3):(<class 'TypeError'>, TypeError('function takes at most 2 arguments (3 given)',))
! >>> Testing StringToChars using d.get(%s)
! d.get(1):(<class 'TypeError'>, TypeError('object must be string',))
! d.get(u"\0"):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.get("\0"):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! d.pop("a"):(<class 'KeyError'>, KeyError('a',))
! dl.pop("a"):(<class 'vim.error'>, error('dict is locked',))
! >> DictionaryIterNext
! for i in ned: ned["a"] = 1:(<class 'RuntimeError'>, RuntimeError('hashtab changed during iteration',))
! >> DictionaryAssItem
! dl["b"] = 1:(<class 'vim.error'>, error('dict is locked',))
! >>> Testing StringToChars using d[%s] = 1
! d[1] = 1:(<class 'TypeError'>, TypeError('object must be string',))
! d[u"\0"] = 1:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d["\0"] = 1:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d["a"] = {%s : 1}
! d["a"] = {1 : 1}:(<class 'TypeError'>, TypeError('object must be string',))
! d["a"] = {u"\0" : 1}:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d["a"] = {"\0" : 1}:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d["a"] = {"abc" : {%s : 1}}
! d["a"] = {"abc" : {1 : 1}}:(<class 'TypeError'>, TypeError('object must be string',))
! d["a"] = {"abc" : {u"\0" : 1}}:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d["a"] = {"abc" : {"\0" : 1}}:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d["a"] = {"abc" : Mapping({%s : 1})}
! d["a"] = {"abc" : Mapping({1 : 1})}:(<class 'TypeError'>, TypeError('object must be string',))
! d["a"] = {"abc" : Mapping({u"\0" : 1})}:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d["a"] = {"abc" : Mapping({"\0" : 1})}:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using d["a"] = {"abc" : %s}
! d["a"] = {"abc" : FailingIter()}:(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = {"abc" : FailingIterNext()}:(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d["a"] = {"abc" : %s}
! d["a"] = {"abc" : None}:(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = {"abc" : {"": 1}}:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! d["a"] = {"abc" : FailingMapping()}:(<class 'NotImplementedError'>, NotImplementedError())
! d["a"] = {"abc" : FailingMappingKey()}:(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using d["a"] = Mapping({%s : 1})
! d["a"] = Mapping({1 : 1}):(<class 'TypeError'>, TypeError('object must be string',))
! d["a"] = Mapping({u"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d["a"] = Mapping({"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d["a"] = Mapping({"abc" : {%s : 1}})
! d["a"] = Mapping({"abc" : {1 : 1}}):(<class 'TypeError'>, TypeError('object must be string',))
! d["a"] = Mapping({"abc" : {u"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d["a"] = Mapping({"abc" : {"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d["a"] = Mapping({"abc" : Mapping({%s : 1})})
! d["a"] = Mapping({"abc" : Mapping({1 : 1})}):(<class 'TypeError'>, TypeError('object must be string',))
! d["a"] = Mapping({"abc" : Mapping({u"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d["a"] = Mapping({"abc" : Mapping({"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using d["a"] = Mapping({"abc" : %s})
! d["a"] = Mapping({"abc" : FailingIter()}):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = Mapping({"abc" : FailingIterNext()}):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d["a"] = Mapping({"abc" : %s})
! d["a"] = Mapping({"abc" : None}):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = Mapping({"abc" : {"": 1}}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! d["a"] = Mapping({"abc" : FailingMapping()}):(<class 'NotImplementedError'>, NotImplementedError())
! d["a"] = Mapping({"abc" : FailingMappingKey()}):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using d["a"] = %s
! d["a"] = FailingIter():(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = FailingIterNext():(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d["a"] = %s
! d["a"] = None:(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = {"": 1}:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! d["a"] = FailingMapping():(<class 'NotImplementedError'>, NotImplementedError())
! d["a"] = FailingMappingKey():(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >> DictionaryUpdate
! >>> kwargs
! >>> iter
! d.update(FailingMapping()):(<class 'NotImplementedError'>, NotImplementedError())
! d.update([FailingIterNext()]):(<class 'NotImplementedError'>, NotImplementedError())
! >>> Testing *Iter* using d.update(%s)
! d.update(FailingIter()):(<class 'NotImplementedError'>, NotImplementedError())
! d.update(FailingIterNext()):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using d.update({%s : 1})
! d.update({1 : 1}):(<class 'TypeError'>, TypeError('object must be string',))
! d.update({u"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.update({"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d.update({"abc" : {%s : 1}})
! d.update({"abc" : {1 : 1}}):(<class 'TypeError'>, TypeError('object must be string',))
! d.update({"abc" : {u"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.update({"abc" : {"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d.update({"abc" : Mapping({%s : 1})})
! d.update({"abc" : Mapping({1 : 1})}):(<class 'TypeError'>, TypeError('object must be string',))
! d.update({"abc" : Mapping({u"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.update({"abc" : Mapping({"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using d.update({"abc" : %s})
! d.update({"abc" : FailingIter()}):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d.update({"abc" : FailingIterNext()}):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d.update({"abc" : %s})
! d.update({"abc" : None}):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d.update({"abc" : {"": 1}}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! d.update({"abc" : FailingMapping()}):(<class 'NotImplementedError'>, NotImplementedError())
! d.update({"abc" : FailingMappingKey()}):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using d.update(Mapping({%s : 1}))
! d.update(Mapping({1 : 1})):(<class 'TypeError'>, TypeError('object must be string',))
! d.update(Mapping({u"\0" : 1})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.update(Mapping({"\0" : 1})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d.update(Mapping({"abc" : {%s : 1}}))
! d.update(Mapping({"abc" : {1 : 1}})):(<class 'TypeError'>, TypeError('object must be string',))
! d.update(Mapping({"abc" : {u"\0" : 1}})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.update(Mapping({"abc" : {"\0" : 1}})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d.update(Mapping({"abc" : Mapping({%s : 1})}))
! d.update(Mapping({"abc" : Mapping({1 : 1})})):(<class 'TypeError'>, TypeError('object must be string',))
! d.update(Mapping({"abc" : Mapping({u"\0" : 1})})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.update(Mapping({"abc" : Mapping({"\0" : 1})})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using d.update(Mapping({"abc" : %s}))
! d.update(Mapping({"abc" : FailingIter()})):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d.update(Mapping({"abc" : FailingIterNext()})):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d.update(Mapping({"abc" : %s}))
! d.update(Mapping({"abc" : None})):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d.update(Mapping({"abc" : {"": 1}})):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! d.update(Mapping({"abc" : FailingMapping()})):(<class 'NotImplementedError'>, NotImplementedError())
! d.update(Mapping({"abc" : FailingMappingKey()})):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using d.update(%s)
! d.update(FailingIter()):(<class 'NotImplementedError'>, NotImplementedError())
! d.update(FailingIterNext()):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d.update(%s)
! d.update(None):(<class 'TypeError'>, TypeError("'NoneType' object is not iterable",))
! d.update({"": 1}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! d.update(FailingMapping()):(<class 'NotImplementedError'>, NotImplementedError())
! d.update(FailingMappingKey()):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using d.update(((%s, 0),))
! d.update(((1, 0),)):(<class 'TypeError'>, TypeError('object must be string',))
! d.update(((u"\0", 0),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.update((("\0", 0),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d.update((("a", {%s : 1}),))
! d.update((("a", {1 : 1}),)):(<class 'TypeError'>, TypeError('object must be string',))
! d.update((("a", {u"\0" : 1}),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.update((("a", {"\0" : 1}),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d.update((("a", {"abc" : {%s : 1}}),))
! d.update((("a", {"abc" : {1 : 1}}),)):(<class 'TypeError'>, TypeError('object must be string',))
! d.update((("a", {"abc" : {u"\0" : 1}}),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.update((("a", {"abc" : {"\0" : 1}}),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d.update((("a", {"abc" : Mapping({%s : 1})}),))
! d.update((("a", {"abc" : Mapping({1 : 1})}),)):(<class 'TypeError'>, TypeError('object must be string',))
! d.update((("a", {"abc" : Mapping({u"\0" : 1})}),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.update((("a", {"abc" : Mapping({"\0" : 1})}),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using d.update((("a", {"abc" : %s}),))
! d.update((("a", {"abc" : FailingIter()}),)):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", {"abc" : FailingIterNext()}),)):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d.update((("a", {"abc" : %s}),))
! d.update((("a", {"abc" : None}),)):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", {"abc" : {"": 1}}),)):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! d.update((("a", {"abc" : FailingMapping()}),)):(<class 'NotImplementedError'>, NotImplementedError())
! d.update((("a", {"abc" : FailingMappingKey()}),)):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using d.update((("a", Mapping({%s : 1})),))
! d.update((("a", Mapping({1 : 1})),)):(<class 'TypeError'>, TypeError('object must be string',))
! d.update((("a", Mapping({u"\0" : 1})),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.update((("a", Mapping({"\0" : 1})),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d.update((("a", Mapping({"abc" : {%s : 1}})),))
! d.update((("a", Mapping({"abc" : {1 : 1}})),)):(<class 'TypeError'>, TypeError('object must be string',))
! d.update((("a", Mapping({"abc" : {u"\0" : 1}})),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.update((("a", Mapping({"abc" : {"\0" : 1}})),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using d.update((("a", Mapping({"abc" : Mapping({%s : 1})})),))
! d.update((("a", Mapping({"abc" : Mapping({1 : 1})})),)):(<class 'TypeError'>, TypeError('object must be string',))
! d.update((("a", Mapping({"abc" : Mapping({u"\0" : 1})})),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! d.update((("a", Mapping({"abc" : Mapping({"\0" : 1})})),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using d.update((("a", Mapping({"abc" : %s})),))
! d.update((("a", Mapping({"abc" : FailingIter()})),)):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", Mapping({"abc" : FailingIterNext()})),)):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d.update((("a", Mapping({"abc" : %s})),))
! d.update((("a", Mapping({"abc" : None})),)):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", Mapping({"abc" : {"": 1}})),)):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! d.update((("a", Mapping({"abc" : FailingMapping()})),)):(<class 'NotImplementedError'>, NotImplementedError())
! d.update((("a", Mapping({"abc" : FailingMappingKey()})),)):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using d.update((("a", %s),))
! d.update((("a", FailingIter()),)):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", FailingIterNext()),)):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using d.update((("a", %s),))
! d.update((("a", None),)):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", {"": 1}),)):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! d.update((("a", FailingMapping()),)):(<class 'NotImplementedError'>, NotImplementedError())
! d.update((("a", FailingMappingKey()),)):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >> DictionaryPopItem
! d.popitem(1, 2):(<class 'TypeError'>, TypeError('function takes exactly 1 argument (2 given)',))
! >> DictionaryHasKey
! d.has_key():(<class 'TypeError'>, TypeError('function takes exactly 1 argument (0 given)',))
! > List
! >> ListConstructor
! vim.List(1, 2):(<class 'TypeError'>, TypeError('function takes at most 1 argument (2 given)',))
! vim.List(a=1):(<class 'TypeError'>, TypeError('list constructor does not accept keyword arguments',))
! >>> Testing *Iter* using vim.List(%s)
! vim.List(FailingIter()):(<class 'NotImplementedError'>, NotImplementedError())
! vim.List(FailingIterNext()):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using vim.List([{%s : 1}])
! vim.List([{1 : 1}]):(<class 'TypeError'>, TypeError('object must be string',))
! vim.List([{u"\0" : 1}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! vim.List([{"\0" : 1}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using vim.List([{"abc" : {%s : 1}}])
! vim.List([{"abc" : {1 : 1}}]):(<class 'TypeError'>, TypeError('object must be string',))
! vim.List([{"abc" : {u"\0" : 1}}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! vim.List([{"abc" : {"\0" : 1}}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using vim.List([{"abc" : Mapping({%s : 1})}])
! vim.List([{"abc" : Mapping({1 : 1})}]):(<class 'TypeError'>, TypeError('object must be string',))
! vim.List([{"abc" : Mapping({u"\0" : 1})}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! vim.List([{"abc" : Mapping({"\0" : 1})}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using vim.List([{"abc" : %s}])
! vim.List([{"abc" : FailingIter()}]):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([{"abc" : FailingIterNext()}]):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using vim.List([{"abc" : %s}])
! vim.List([{"abc" : None}]):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([{"abc" : {"": 1}}]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! vim.List([{"abc" : FailingMapping()}]):(<class 'NotImplementedError'>, NotImplementedError())
! vim.List([{"abc" : FailingMappingKey()}]):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using vim.List([Mapping({%s : 1})])
! vim.List([Mapping({1 : 1})]):(<class 'TypeError'>, TypeError('object must be string',))
! vim.List([Mapping({u"\0" : 1})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! vim.List([Mapping({"\0" : 1})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using vim.List([Mapping({"abc" : {%s : 1}})])
! vim.List([Mapping({"abc" : {1 : 1}})]):(<class 'TypeError'>, TypeError('object must be string',))
! vim.List([Mapping({"abc" : {u"\0" : 1}})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! vim.List([Mapping({"abc" : {"\0" : 1}})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using vim.List([Mapping({"abc" : Mapping({%s : 1})})])
! vim.List([Mapping({"abc" : Mapping({1 : 1})})]):(<class 'TypeError'>, TypeError('object must be string',))
! vim.List([Mapping({"abc" : Mapping({u"\0" : 1})})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! vim.List([Mapping({"abc" : Mapping({"\0" : 1})})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using vim.List([Mapping({"abc" : %s})])
! vim.List([Mapping({"abc" : FailingIter()})]):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([Mapping({"abc" : FailingIterNext()})]):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using vim.List([Mapping({"abc" : %s})])
! vim.List([Mapping({"abc" : None})]):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([Mapping({"abc" : {"": 1}})]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! vim.List([Mapping({"abc" : FailingMapping()})]):(<class 'NotImplementedError'>, NotImplementedError())
! vim.List([Mapping({"abc" : FailingMappingKey()})]):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using vim.List([%s])
! vim.List([FailingIter()]):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([FailingIterNext()]):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using vim.List([%s])
! vim.List([None]):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([{"": 1}]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! vim.List([FailingMapping()]):(<class 'NotImplementedError'>, NotImplementedError())
! vim.List([FailingMappingKey()]):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >> ListItem
! l[1000]:(<class 'IndexError'>, IndexError('list index out of range',))
! >> ListAssItem
! ll[1] = 2:(<class 'vim.error'>, error('list is locked',))
! l[1000] = 3:(<class 'IndexError'>, IndexError('list index out of range',))
! >> ListAssSlice
! ll[1:100] = "abc":(<class 'vim.error'>, error('list is locked',))
! >>> Testing *Iter* using l[:] = %s
! l[:] = FailingIter():(<class 'NotImplementedError'>, NotImplementedError())
! l[:] = FailingIterNext()::(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using l[:] = [{%s : 1}]
! l[:] = [{1 : 1}]:(<class 'TypeError'>, TypeError('object must be string',))
! l[:] = [{u"\0" : 1}]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! l[:] = [{"\0" : 1}]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using l[:] = [{"abc" : {%s : 1}}]
! l[:] = [{"abc" : {1 : 1}}]:(<class 'TypeError'>, TypeError('object must be string',))
! l[:] = [{"abc" : {u"\0" : 1}}]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! l[:] = [{"abc" : {"\0" : 1}}]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using l[:] = [{"abc" : Mapping({%s : 1})}]
! l[:] = [{"abc" : Mapping({1 : 1})}]:(<class 'TypeError'>, TypeError('object must be string',))
! l[:] = [{"abc" : Mapping({u"\0" : 1})}]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! l[:] = [{"abc" : Mapping({"\0" : 1})}]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using l[:] = [{"abc" : %s}]
! l[:] = [{"abc" : FailingIter()}]:(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [{"abc" : FailingIterNext()}]:(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using l[:] = [{"abc" : %s}]
! l[:] = [{"abc" : None}]:(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [{"abc" : {"": 1}}]:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! l[:] = [{"abc" : FailingMapping()}]:(<class 'NotImplementedError'>, NotImplementedError())
! l[:] = [{"abc" : FailingMappingKey()}]:(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using l[:] = [Mapping({%s : 1})]
! l[:] = [Mapping({1 : 1})]:(<class 'TypeError'>, TypeError('object must be string',))
! l[:] = [Mapping({u"\0" : 1})]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! l[:] = [Mapping({"\0" : 1})]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using l[:] = [Mapping({"abc" : {%s : 1}})]
! l[:] = [Mapping({"abc" : {1 : 1}})]:(<class 'TypeError'>, TypeError('object must be string',))
! l[:] = [Mapping({"abc" : {u"\0" : 1}})]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! l[:] = [Mapping({"abc" : {"\0" : 1}})]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using l[:] = [Mapping({"abc" : Mapping({%s : 1})})]
! l[:] = [Mapping({"abc" : Mapping({1 : 1})})]:(<class 'TypeError'>, TypeError('object must be string',))
! l[:] = [Mapping({"abc" : Mapping({u"\0" : 1})})]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! l[:] = [Mapping({"abc" : Mapping({"\0" : 1})})]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using l[:] = [Mapping({"abc" : %s})]
! l[:] = [Mapping({"abc" : FailingIter()})]:(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [Mapping({"abc" : FailingIterNext()})]:(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using l[:] = [Mapping({"abc" : %s})]
! l[:] = [Mapping({"abc" : None})]:(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [Mapping({"abc" : {"": 1}})]:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! l[:] = [Mapping({"abc" : FailingMapping()})]:(<class 'NotImplementedError'>, NotImplementedError())
! l[:] = [Mapping({"abc" : FailingMappingKey()})]:(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using l[:] = [%s]
! l[:] = [FailingIter()]:(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [FailingIterNext()]:(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using l[:] = [%s]
! l[:] = [None]:(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [{"": 1}]:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! l[:] = [FailingMapping()]:(<class 'NotImplementedError'>, NotImplementedError())
! l[:] = [FailingMappingKey()]:(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >> ListConcatInPlace
! >>> Testing *Iter* using l.extend(%s)
! l.extend(FailingIter()):(<class 'NotImplementedError'>, NotImplementedError())
! l.extend(FailingIterNext()):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using l.extend([{%s : 1}])
! l.extend([{1 : 1}]):(<class 'TypeError'>, TypeError('object must be string',))
! l.extend([{u"\0" : 1}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! l.extend([{"\0" : 1}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using l.extend([{"abc" : {%s : 1}}])
! l.extend([{"abc" : {1 : 1}}]):(<class 'TypeError'>, TypeError('object must be string',))
! l.extend([{"abc" : {u"\0" : 1}}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! l.extend([{"abc" : {"\0" : 1}}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using l.extend([{"abc" : Mapping({%s : 1})}])
! l.extend([{"abc" : Mapping({1 : 1})}]):(<class 'TypeError'>, TypeError('object must be string',))
! l.extend([{"abc" : Mapping({u"\0" : 1})}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! l.extend([{"abc" : Mapping({"\0" : 1})}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using l.extend([{"abc" : %s}])
! l.extend([{"abc" : FailingIter()}]):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([{"abc" : FailingIterNext()}]):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using l.extend([{"abc" : %s}])
! l.extend([{"abc" : None}]):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([{"abc" : {"": 1}}]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! l.extend([{"abc" : FailingMapping()}]):(<class 'NotImplementedError'>, NotImplementedError())
! l.extend([{"abc" : FailingMappingKey()}]):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using l.extend([Mapping({%s : 1})])
! l.extend([Mapping({1 : 1})]):(<class 'TypeError'>, TypeError('object must be string',))
! l.extend([Mapping({u"\0" : 1})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! l.extend([Mapping({"\0" : 1})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using l.extend([Mapping({"abc" : {%s : 1}})])
! l.extend([Mapping({"abc" : {1 : 1}})]):(<class 'TypeError'>, TypeError('object must be string',))
! l.extend([Mapping({"abc" : {u"\0" : 1}})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! l.extend([Mapping({"abc" : {"\0" : 1}})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using l.extend([Mapping({"abc" : Mapping({%s : 1})})])
! l.extend([Mapping({"abc" : Mapping({1 : 1})})]):(<class 'TypeError'>, TypeError('object must be string',))
! l.extend([Mapping({"abc" : Mapping({u"\0" : 1})})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! l.extend([Mapping({"abc" : Mapping({"\0" : 1})})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using l.extend([Mapping({"abc" : %s})])
! l.extend([Mapping({"abc" : FailingIter()})]):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([Mapping({"abc" : FailingIterNext()})]):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using l.extend([Mapping({"abc" : %s})])
! l.extend([Mapping({"abc" : None})]):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([Mapping({"abc" : {"": 1}})]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! l.extend([Mapping({"abc" : FailingMapping()})]):(<class 'NotImplementedError'>, NotImplementedError())
! l.extend([Mapping({"abc" : FailingMappingKey()})]):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using l.extend([%s])
! l.extend([FailingIter()]):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([FailingIterNext()]):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using l.extend([%s])
! l.extend([None]):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([{"": 1}]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! l.extend([FailingMapping()]):(<class 'NotImplementedError'>, NotImplementedError())
! l.extend([FailingMappingKey()]):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >> ListSetattr
! del l.locked:(<class 'AttributeError'>, AttributeError('cannot delete vim.List attributes',))
! l.locked = FailingTrue():(<class 'NotImplementedError'>, NotImplementedError())
! l.xxx = True:(<class 'AttributeError'>, AttributeError('cannot set this attribute',))
! > Function
! >> FunctionConstructor
! vim.Function("123"):(<class 'ValueError'>, ValueError('unnamed function does not exist',))
! vim.Function("xxx_non_existent_function_xxx"):(<class 'ValueError'>, ValueError('function does not exist',))
! vim.Function("xxx#non#existent#function#xxx"):(<class 'ValueError'>, ValueError('function does not exist',))
! >> FunctionCall
! >>> Testing StringToChars using f({%s : 1})
! f({1 : 1}):(<class 'TypeError'>, TypeError('object must be string',))
! f({u"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! f({"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using f({"abc" : {%s : 1}})
! f({"abc" : {1 : 1}}):(<class 'TypeError'>, TypeError('object must be string',))
! f({"abc" : {u"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! f({"abc" : {"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using f({"abc" : Mapping({%s : 1})})
! f({"abc" : Mapping({1 : 1})}):(<class 'TypeError'>, TypeError('object must be string',))
! f({"abc" : Mapping({u"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! f({"abc" : Mapping({"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using f({"abc" : %s})
! f({"abc" : FailingIter()}):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! f({"abc" : FailingIterNext()}):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using f({"abc" : %s})
! f({"abc" : None}):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! f({"abc" : {"": 1}}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! f({"abc" : FailingMapping()}):(<class 'NotImplementedError'>, NotImplementedError())
! f({"abc" : FailingMappingKey()}):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using f(Mapping({%s : 1}))
! f(Mapping({1 : 1})):(<class 'TypeError'>, TypeError('object must be string',))
! f(Mapping({u"\0" : 1})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! f(Mapping({"\0" : 1})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using f(Mapping({"abc" : {%s : 1}}))
! f(Mapping({"abc" : {1 : 1}})):(<class 'TypeError'>, TypeError('object must be string',))
! f(Mapping({"abc" : {u"\0" : 1}})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! f(Mapping({"abc" : {"\0" : 1}})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using f(Mapping({"abc" : Mapping({%s : 1})}))
! f(Mapping({"abc" : Mapping({1 : 1})})):(<class 'TypeError'>, TypeError('object must be string',))
! f(Mapping({"abc" : Mapping({u"\0" : 1})})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! f(Mapping({"abc" : Mapping({"\0" : 1})})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using f(Mapping({"abc" : %s}))
! f(Mapping({"abc" : FailingIter()})):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! f(Mapping({"abc" : FailingIterNext()})):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using f(Mapping({"abc" : %s}))
! f(Mapping({"abc" : None})):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! f(Mapping({"abc" : {"": 1}})):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! f(Mapping({"abc" : FailingMapping()})):(<class 'NotImplementedError'>, NotImplementedError())
! f(Mapping({"abc" : FailingMappingKey()})):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using f(%s)
! f(FailingIter()):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! f(FailingIterNext()):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using f(%s)
! f(None):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! f({"": 1}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! f(FailingMapping()):(<class 'NotImplementedError'>, NotImplementedError())
! f(FailingMappingKey()):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using fd(self={%s : 1})
! fd(self={1 : 1}):(<class 'TypeError'>, TypeError('object must be string',))
! fd(self={u"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! fd(self={"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using fd(self={"abc" : {%s : 1}})
! fd(self={"abc" : {1 : 1}}):(<class 'TypeError'>, TypeError('object must be string',))
! fd(self={"abc" : {u"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! fd(self={"abc" : {"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using fd(self={"abc" : Mapping({%s : 1})})
! fd(self={"abc" : Mapping({1 : 1})}):(<class 'TypeError'>, TypeError('object must be string',))
! fd(self={"abc" : Mapping({u"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! fd(self={"abc" : Mapping({"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using fd(self={"abc" : %s})
! fd(self={"abc" : FailingIter()}):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! fd(self={"abc" : FailingIterNext()}):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using fd(self={"abc" : %s})
! fd(self={"abc" : None}):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! fd(self={"abc" : {"": 1}}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! fd(self={"abc" : FailingMapping()}):(<class 'NotImplementedError'>, NotImplementedError())
! fd(self={"abc" : FailingMappingKey()}):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing StringToChars using fd(self=Mapping({%s : 1}))
! fd(self=Mapping({1 : 1})):(<class 'TypeError'>, TypeError('object must be string',))
! fd(self=Mapping({u"\0" : 1})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! fd(self=Mapping({"\0" : 1})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using fd(self=Mapping({"abc" : {%s : 1}}))
! fd(self=Mapping({"abc" : {1 : 1}})):(<class 'TypeError'>, TypeError('object must be string',))
! fd(self=Mapping({"abc" : {u"\0" : 1}})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! fd(self=Mapping({"abc" : {"\0" : 1}})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing StringToChars using fd(self=Mapping({"abc" : Mapping({%s : 1})}))
! fd(self=Mapping({"abc" : Mapping({1 : 1})})):(<class 'TypeError'>, TypeError('object must be string',))
! fd(self=Mapping({"abc" : Mapping({u"\0" : 1})})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! fd(self=Mapping({"abc" : Mapping({"\0" : 1})})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
! <<< Finished
! >>> Testing *Iter* using fd(self=Mapping({"abc" : %s}))
! fd(self=Mapping({"abc" : FailingIter()})):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! fd(self=Mapping({"abc" : FailingIterNext()})):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyObject using fd(self=Mapping({"abc" : %s}))
! fd(self=Mapping({"abc" : None})):(<class 'TypeError'>, TypeError('unable to convert to vim structure',))
! fd(self=Mapping({"abc" : {"": 1}})):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! fd(self=Mapping({"abc" : FailingMapping()})):(<class 'NotImplementedError'>, NotImplementedError())
! fd(self=Mapping({"abc" : FailingMappingKey()})):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing *Iter* using fd(self=%s)
! fd(self=FailingIter()):(<class 'TypeError'>, TypeError('unable to convert object to vim dictionary',))
! fd(self=FailingIterNext()):(<class 'TypeError'>, TypeError('unable to convert object to vim dictionary',))
! <<< Finished
! >>> Testing ConvertFromPyObject using fd(self=%s)
! fd(self=None):(<class 'TypeError'>, TypeError('unable to convert object to vim dictionary',))
! fd(self={"": 1}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
! fd(self=FailingMapping()):(<class 'NotImplementedError'>, NotImplementedError())
! fd(self=FailingMappingKey()):(<class 'NotImplementedError'>, NotImplementedError())
! <<< Finished
! >>> Testing ConvertFromPyMapping using fd(self=%s)
! fd(self=[]):(<class 'AttributeError'>, AttributeError("'list' object has no attribute 'keys'",))
! <<< Finished
! > TabPage
! >> TabPageAttr
! vim.current.tabpage.xxx:(<class 'AttributeError'>, AttributeError("'vim.tabpage' object has no attribute 'xxx'",))
! > TabList
! >> TabListItem
! vim.tabpages[1000]:(<class 'IndexError'>, IndexError('no such tab page',))
! > Window
! >> WindowAttr
! vim.current.window.xxx:(<class 'AttributeError'>, AttributeError("'vim.window' object has no attribute 'xxx'",))
! >> WindowSetattr
! vim.current.window.buffer = 0:(<class 'TypeError'>, TypeError('readonly attribute',))
! vim.current.window.cursor = (10000000000, 100000000):(<class 'vim.error'>, error('cursor position outside buffer',))
! vim.current.window.cursor = True:(<class 'TypeError'>, TypeError('argument must be 2-item sequence, not bool',))
! vim.current.window.height = "abc":(<class 'TypeError'>, TypeError('an integer is required',))
! vim.current.window.width  = "abc":(<class 'TypeError'>, TypeError('an integer is required',))
! vim.current.window.xxxxxx = True:(<class 'AttributeError'>, AttributeError('xxxxxx',))
! > WinList
! >> WinListItem
! vim.windows[1000]:(<class 'IndexError'>, IndexError('no such window',))
! > Buffer
! >> StringToLine (indirect)
! vim.current.buffer[0] = "\na":(<class 'vim.error'>, error('string cannot contain newlines',))
! >> SetBufferLine (indirect)
! vim.current.buffer[0] = True:(<class 'TypeError'>, TypeError('bad argument type for built-in operation',))
! >> SetBufferLines (indirect)
! vim.current.buffer[:] = True:(<class 'TypeError'>, TypeError('bad argument type for built-in operation',))
! vim.current.buffer[:] = ["\na", "bc"]:(<class 'vim.error'>, error('string cannot contain newlines',))
! >> InsertBufferLines (indirect)
! vim.current.buffer.append(None):(<class 'TypeError'>, TypeError('bad argument type for built-in operation',))
! vim.current.buffer.append(["\na", "bc"]):(<class 'vim.error'>, error('string cannot contain newlines',))
! vim.current.buffer.append("\nbc"):(<class 'vim.error'>, error('string cannot contain newlines',))
! >> RBItem
! vim.current.buffer[10000000000]:(<class 'IndexError'>, IndexError('line number out of range',))
! >> RBAsItem
! vim.current.buffer[10000000000] = "":(<class 'IndexError'>, IndexError('line number out of range',))
! >> BufferAttr
! vim.current.buffer.xxx:(<class 'AttributeError'>, AttributeError("'vim.buffer' object has no attribute 'xxx'",))
! >> BufferSetattr
! vim.current.buffer.name = True:(<class 'TypeError'>, TypeError('object must be string',))
! vim.current.buffer.xxx = True:(<class 'AttributeError'>, AttributeError('xxx',))
! >> BufferMark
! vim.current.buffer.mark(0):(<class 'TypeError'>, TypeError('must be str, not int',))
! vim.current.buffer.mark("abc"):(<class 'ValueError'>, ValueError('mark name must be a single character',))
! vim.current.buffer.mark("!"):(<class 'vim.error'>, error('invalid mark name',))
! >> BufferRange
! vim.current.buffer.range(1, 2, 3):(<class 'TypeError'>, TypeError('function takes exactly 2 arguments (3 given)',))
! > BufMap
! >> BufMapItem
! vim.buffers[None]:(<class 'TypeError'>, TypeError('key must be integer',))
! vim.buffers[100000000]:(<class 'KeyError'>, KeyError(100000000,))
! > Current
! >> CurrentGetattr
! vim.current.xxx:(<class 'AttributeError'>, AttributeError("'vim.currentdata' object has no attribute 'xxx'",))
! >> CurrentSetattr
! vim.current.line = True:(<class 'TypeError'>, TypeError('bad argument type for built-in operation',))
! vim.current.buffer = True:(<class 'TypeError'>, TypeError('expected vim.Buffer object',))
! vim.current.window = True:(<class 'TypeError'>, TypeError('expected vim.Window object',))
! vim.current.tabpage = True:(<class 'TypeError'>, TypeError('expected vim.TabPage object',))
! vim.current.xxx = True:(<class 'AttributeError'>, AttributeError('xxx',))
! vim.command("throw 'abc'"):(<class 'vim.error'>, error('abc',))
! Exe("throw 'def'"):(<class 'vim.error'>, error('def',))
! vim.eval("Exe('throw ''ghi''')"):(<class 'vim.error'>, error('ghi',))
! vim.eval("Exe('echoerr ''jkl''')"):(<class 'vim.error'>, error('Vim(echoerr):jkl',))
! vim.eval("Exe('xxx_non_existent_command_xxx')"):(<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
! vim.bindeval("Exe('xxx_non_existent_command_xxx')"):(<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
*** ../vim-7.3.1065/src/version.c	2013-05-30 13:22:07.000000000 +0200
--- src/version.c	2013-05-30 13:24:41.000000000 +0200
***************
*** 730,731 ****
--- 730,733 ----
  {   /* Add new patch number below this line */
+ /**/
+     1066,
  /**/

-- 
If Pacman had affected us as kids we'd be running around in dark rooms,
munching pills and listening to repetitive music.
                       -- Marcus Brigstocke

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
