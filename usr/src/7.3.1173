To: vim_dev@googlegroups.com
Subject: Patch 7.3.1173
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.3.1173
Problem:    Python 2 tests don't have the same output everywhere.
Solution:   Make the Python 2 tests more portable. (ZyX)
Files:	    src/testdir/test86.in, src/testdir/test86.ok


*** ../vim-7.3.1172/src/testdir/test86.in	2013-06-12 14:20:15.000000000 +0200
--- src/testdir/test86.in	2013-06-12 14:21:28.000000000 +0200
***************
*** 45,53 ****
  dk = d.keys()
  dv = d.values()
  di = d.items()
! dk.sort(key=repr)
! dv.sort(key=repr)
! di.sort(key=repr)
  EOF
  :$put =pyeval('d[''f''](self={})')
  :$put =pyeval('repr(dk)')
--- 45,54 ----
  dk = d.keys()
  dv = d.values()
  di = d.items()
! cmpfun = lambda a, b: cmp(repr(a), repr(b))
! dk.sort(cmpfun)
! dv.sort(cmpfun)
! di.sort(cmpfun)
  EOF
  :$put =pyeval('d[''f''](self={})')
  :$put =pyeval('repr(dk)')
***************
*** 813,819 ****
      try:
          exec(expr, g, l)
      except:
!         cb.append(expr + ':' + repr(sys.exc_info()[:2]))
      else:
          cb.append(expr + ':NOT FAILED')
  d = vim.Dictionary()
--- 814,830 ----
      try:
          exec(expr, g, l)
      except:
!         ei = sys.exc_info()
!         msg = sys.exc_info()[0].__name__ + ':' + repr(sys.exc_info()[1].args)
!         msg = msg.replace('TypeError:(\'argument 1 ', 'TypeError:(\'')
!         if expr.find('None') > -1:
!             msg = msg.replace('TypeError:(\'iteration over non-sequence\',)',
!                               'TypeError:("\'NoneType\' object is not iterable",)')
!         if expr == 'fd(self=[])':
!             # HACK: PyMapping_Check changed meaning
!             msg = msg.replace('AttributeError:(\'keys\',)',
!                               'TypeError:(\'unable to convert object to vim dictionary\',)')
!         cb.append(expr + ':' + msg)
      else:
          cb.append(expr + ':NOT FAILED')
  d = vim.Dictionary()
*** ../vim-7.3.1172/src/testdir/test86.ok	2013-06-12 14:20:15.000000000 +0200
--- src/testdir/test86.ok	2013-06-12 14:21:28.000000000 +0200
***************
*** 437,1094 ****
  test86.in
  > Output
  >> OutputSetattr
! del sys.stdout.softspace:(<type 'exceptions.AttributeError'>, AttributeError("can't delete OutputObject attributes",))
! sys.stdout.softspace = []:(<type 'exceptions.TypeError'>, TypeError('softspace must be an integer',))
! sys.stdout.attr = None:(<type 'exceptions.AttributeError'>, AttributeError('invalid attribute',))
  >> OutputWrite
! sys.stdout.write(None):(<type 'exceptions.TypeError'>, TypeError('coercing to Unicode: need string or buffer, NoneType found',))
  >> OutputWriteLines
! sys.stdout.writelines(None):(<type 'exceptions.TypeError'>, TypeError("'NoneType' object is not iterable",))
! sys.stdout.writelines([1]):(<type 'exceptions.TypeError'>, TypeError('writelines() requires list of strings',))
  > VimCommand
! vim.command(1):(<type 'exceptions.TypeError'>, TypeError('must be string, not int',))
  > VimToPython
  > VimEval
! vim.eval(1):(<type 'exceptions.TypeError'>, TypeError('must be string, not int',))
  > VimEvalPy
! vim.bindeval(1):(<type 'exceptions.TypeError'>, TypeError('must be string, not int',))
  > VimStrwidth
! vim.strwidth(1):(<type 'exceptions.TypeError'>, TypeError('must be string, not int',))
  > Dictionary
  >> DictionaryConstructor
! vim.Dictionary("abc"):(<type 'exceptions.ValueError'>, ValueError('expected sequence element of size 2',))
  >> DictionarySetattr
! del d.locked:(<type 'exceptions.AttributeError'>, AttributeError('cannot delete vim.Dictionary attributes',))
! d.locked = FailingTrue():(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! vim.vvars.locked = False:(<type 'exceptions.TypeError'>, TypeError('cannot modify fixed dictionary',))
! d.scope = True:(<type 'exceptions.AttributeError'>, AttributeError('cannot set this attribute',))
! d.xxx = True:(<type 'exceptions.AttributeError'>, AttributeError('cannot set this attribute',))
  >> _DictionaryItem
! d.get("a", 2, 3):(<type 'exceptions.TypeError'>, TypeError('function takes at most 2 arguments (3 given)',))
  >>> Testing StringToChars using d.get(%s)
! d.get(1):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.get(u"\0"):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.get("\0"):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
! d.pop("a"):(<type 'exceptions.KeyError'>, KeyError('a',))
! dl.pop("a"):(<class 'vim.error'>, error('dict is locked',))
  >> DictionaryIterNext
! for i in ned: ned["a"] = 1:(<type 'exceptions.RuntimeError'>, RuntimeError('hashtab changed during iteration',))
  >> DictionaryAssItem
! dl["b"] = 1:(<class 'vim.error'>, error('dict is locked',))
  >>> Testing StringToChars using d[%s] = 1
! d[1] = 1:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d[u"\0"] = 1:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["\0"] = 1:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d["a"] = {%s : 1}
! d["a"] = {1 : 1}:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d["a"] = {u"\0" : 1}:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["a"] = {"\0" : 1}:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d["a"] = {"abc" : {%s : 1}}
! d["a"] = {"abc" : {1 : 1}}:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d["a"] = {"abc" : {u"\0" : 1}}:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["a"] = {"abc" : {"\0" : 1}}:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d["a"] = {"abc" : Mapping({%s : 1})}
! d["a"] = {"abc" : Mapping({1 : 1})}:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d["a"] = {"abc" : Mapping({u"\0" : 1})}:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["a"] = {"abc" : Mapping({"\0" : 1})}:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using d["a"] = {"abc" : %s}
! d["a"] = {"abc" : FailingIter()}:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = {"abc" : FailingIterNext()}:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using d["a"] = {"abc" : %s}
! d["a"] = {"abc" : None}:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = {"abc" : {"": 1}}:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d["a"] = {"abc" : {u"": 1}}:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d["a"] = {"abc" : FailingMapping()}:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d["a"] = {"abc" : FailingMappingKey()}:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing StringToChars using d["a"] = Mapping({%s : 1})
! d["a"] = Mapping({1 : 1}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d["a"] = Mapping({u"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["a"] = Mapping({"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d["a"] = Mapping({"abc" : {%s : 1}})
! d["a"] = Mapping({"abc" : {1 : 1}}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d["a"] = Mapping({"abc" : {u"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["a"] = Mapping({"abc" : {"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d["a"] = Mapping({"abc" : Mapping({%s : 1})})
! d["a"] = Mapping({"abc" : Mapping({1 : 1})}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d["a"] = Mapping({"abc" : Mapping({u"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d["a"] = Mapping({"abc" : Mapping({"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using d["a"] = Mapping({"abc" : %s})
! d["a"] = Mapping({"abc" : FailingIter()}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = Mapping({"abc" : FailingIterNext()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using d["a"] = Mapping({"abc" : %s})
! d["a"] = Mapping({"abc" : None}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = Mapping({"abc" : {"": 1}}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d["a"] = Mapping({"abc" : {u"": 1}}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d["a"] = Mapping({"abc" : FailingMapping()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d["a"] = Mapping({"abc" : FailingMappingKey()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing *Iter* using d["a"] = %s
! d["a"] = FailingIter():(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = FailingIterNext():(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using d["a"] = %s
! d["a"] = None:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d["a"] = {"": 1}:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d["a"] = {u"": 1}:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d["a"] = FailingMapping():(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d["a"] = FailingMappingKey():(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >> DictionaryUpdate
  >>> kwargs
  >>> iter
! d.update(FailingMapping()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update([FailingIterNext()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  >>> Testing StringToChars using d.update({%s : 1})
! d.update({1 : 1}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update({u"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update({"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d.update({"abc" : {%s : 1}})
! d.update({"abc" : {1 : 1}}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update({"abc" : {u"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update({"abc" : {"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d.update({"abc" : Mapping({%s : 1})})
! d.update({"abc" : Mapping({1 : 1})}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update({"abc" : Mapping({u"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update({"abc" : Mapping({"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using d.update({"abc" : %s})
! d.update({"abc" : FailingIter()}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update({"abc" : FailingIterNext()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using d.update({"abc" : %s})
! d.update({"abc" : None}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update({"abc" : {"": 1}}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update({"abc" : {u"": 1}}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update({"abc" : FailingMapping()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update({"abc" : FailingMappingKey()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing StringToChars using d.update(Mapping({%s : 1}))
! d.update(Mapping({1 : 1})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update(Mapping({u"\0" : 1})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update(Mapping({"\0" : 1})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d.update(Mapping({"abc" : {%s : 1}}))
! d.update(Mapping({"abc" : {1 : 1}})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update(Mapping({"abc" : {u"\0" : 1}})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update(Mapping({"abc" : {"\0" : 1}})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d.update(Mapping({"abc" : Mapping({%s : 1})}))
! d.update(Mapping({"abc" : Mapping({1 : 1})})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update(Mapping({"abc" : Mapping({u"\0" : 1})})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update(Mapping({"abc" : Mapping({"\0" : 1})})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using d.update(Mapping({"abc" : %s}))
! d.update(Mapping({"abc" : FailingIter()})):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update(Mapping({"abc" : FailingIterNext()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using d.update(Mapping({"abc" : %s}))
! d.update(Mapping({"abc" : None})):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update(Mapping({"abc" : {"": 1}})):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update(Mapping({"abc" : {u"": 1}})):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update(Mapping({"abc" : FailingMapping()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update(Mapping({"abc" : FailingMappingKey()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing *Iter* using d.update(%s)
! d.update(FailingIter()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update(FailingIterNext()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using d.update(%s)
! d.update(None):(<type 'exceptions.TypeError'>, TypeError("'NoneType' object is not iterable",))
! d.update({"": 1}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update({u"": 1}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update(FailingMapping()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update(FailingMappingKey()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing StringToChars using d.update(((%s, 0),))
! d.update(((1, 0),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update(((u"\0", 0),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("\0", 0),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d.update((("a", {%s : 1}),))
! d.update((("a", {1 : 1}),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update((("a", {u"\0" : 1}),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("a", {"\0" : 1}),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d.update((("a", {"abc" : {%s : 1}}),))
! d.update((("a", {"abc" : {1 : 1}}),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update((("a", {"abc" : {u"\0" : 1}}),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("a", {"abc" : {"\0" : 1}}),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d.update((("a", {"abc" : Mapping({%s : 1})}),))
! d.update((("a", {"abc" : Mapping({1 : 1})}),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update((("a", {"abc" : Mapping({u"\0" : 1})}),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("a", {"abc" : Mapping({"\0" : 1})}),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using d.update((("a", {"abc" : %s}),))
! d.update((("a", {"abc" : FailingIter()}),)):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", {"abc" : FailingIterNext()}),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using d.update((("a", {"abc" : %s}),))
! d.update((("a", {"abc" : None}),)):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", {"abc" : {"": 1}}),)):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update((("a", {"abc" : {u"": 1}}),)):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update((("a", {"abc" : FailingMapping()}),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update((("a", {"abc" : FailingMappingKey()}),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing StringToChars using d.update((("a", Mapping({%s : 1})),))
! d.update((("a", Mapping({1 : 1})),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update((("a", Mapping({u"\0" : 1})),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("a", Mapping({"\0" : 1})),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d.update((("a", Mapping({"abc" : {%s : 1}})),))
! d.update((("a", Mapping({"abc" : {1 : 1}})),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update((("a", Mapping({"abc" : {u"\0" : 1}})),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("a", Mapping({"abc" : {"\0" : 1}})),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using d.update((("a", Mapping({"abc" : Mapping({%s : 1})})),))
! d.update((("a", Mapping({"abc" : Mapping({1 : 1})})),)):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! d.update((("a", Mapping({"abc" : Mapping({u"\0" : 1})})),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! d.update((("a", Mapping({"abc" : Mapping({"\0" : 1})})),)):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using d.update((("a", Mapping({"abc" : %s})),))
! d.update((("a", Mapping({"abc" : FailingIter()})),)):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", Mapping({"abc" : FailingIterNext()})),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using d.update((("a", Mapping({"abc" : %s})),))
! d.update((("a", Mapping({"abc" : None})),)):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", Mapping({"abc" : {"": 1}})),)):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update((("a", Mapping({"abc" : {u"": 1}})),)):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update((("a", Mapping({"abc" : FailingMapping()})),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update((("a", Mapping({"abc" : FailingMappingKey()})),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing *Iter* using d.update((("a", %s),))
! d.update((("a", FailingIter()),)):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", FailingIterNext()),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using d.update((("a", %s),))
! d.update((("a", None),)):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! d.update((("a", {"": 1}),)):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update((("a", {u"": 1}),)):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! d.update((("a", FailingMapping()),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! d.update((("a", FailingMappingKey()),)):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >> DictionaryPopItem
! d.popitem(1, 2):(<type 'exceptions.TypeError'>, TypeError('popitem() takes no arguments (2 given)',))
  >> DictionaryHasKey
! d.has_key():(<type 'exceptions.TypeError'>, TypeError('function takes exactly 1 argument (0 given)',))
  > List
  >> ListConstructor
! vim.List(1, 2):(<type 'exceptions.TypeError'>, TypeError('function takes at most 1 argument (2 given)',))
! vim.List(a=1):(<type 'exceptions.TypeError'>, TypeError('list constructor does not accept keyword arguments',))
  >>> Testing StringToChars using vim.List([{%s : 1}])
! vim.List([{1 : 1}]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.List([{u"\0" : 1}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! vim.List([{"\0" : 1}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using vim.List([{"abc" : {%s : 1}}])
! vim.List([{"abc" : {1 : 1}}]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.List([{"abc" : {u"\0" : 1}}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! vim.List([{"abc" : {"\0" : 1}}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using vim.List([{"abc" : Mapping({%s : 1})}])
! vim.List([{"abc" : Mapping({1 : 1})}]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.List([{"abc" : Mapping({u"\0" : 1})}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! vim.List([{"abc" : Mapping({"\0" : 1})}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using vim.List([{"abc" : %s}])
! vim.List([{"abc" : FailingIter()}]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([{"abc" : FailingIterNext()}]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using vim.List([{"abc" : %s}])
! vim.List([{"abc" : None}]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([{"abc" : {"": 1}}]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! vim.List([{"abc" : {u"": 1}}]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! vim.List([{"abc" : FailingMapping()}]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! vim.List([{"abc" : FailingMappingKey()}]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing StringToChars using vim.List([Mapping({%s : 1})])
! vim.List([Mapping({1 : 1})]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.List([Mapping({u"\0" : 1})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! vim.List([Mapping({"\0" : 1})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using vim.List([Mapping({"abc" : {%s : 1}})])
! vim.List([Mapping({"abc" : {1 : 1}})]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.List([Mapping({"abc" : {u"\0" : 1}})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! vim.List([Mapping({"abc" : {"\0" : 1}})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using vim.List([Mapping({"abc" : Mapping({%s : 1})})])
! vim.List([Mapping({"abc" : Mapping({1 : 1})})]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.List([Mapping({"abc" : Mapping({u"\0" : 1})})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! vim.List([Mapping({"abc" : Mapping({"\0" : 1})})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using vim.List([Mapping({"abc" : %s})])
! vim.List([Mapping({"abc" : FailingIter()})]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([Mapping({"abc" : FailingIterNext()})]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using vim.List([Mapping({"abc" : %s})])
! vim.List([Mapping({"abc" : None})]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([Mapping({"abc" : {"": 1}})]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! vim.List([Mapping({"abc" : {u"": 1}})]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! vim.List([Mapping({"abc" : FailingMapping()})]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! vim.List([Mapping({"abc" : FailingMappingKey()})]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing *Iter* using vim.List([%s])
! vim.List([FailingIter()]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([FailingIterNext()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using vim.List([%s])
! vim.List([None]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! vim.List([{"": 1}]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! vim.List([{u"": 1}]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! vim.List([FailingMapping()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! vim.List([FailingMappingKey()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >> ListItem
! l[1000]:(<type 'exceptions.IndexError'>, IndexError('list index out of range',))
  >> ListAssItem
! ll[1] = 2:(<class 'vim.error'>, error('list is locked',))
! l[1000] = 3:(<type 'exceptions.IndexError'>, IndexError('list index out of range',))
  >> ListAssSlice
! ll[1:100] = "abc":(<class 'vim.error'>, error('list is locked',))
  >>> Testing StringToChars using l[:] = [{%s : 1}]
! l[:] = [{1 : 1}]:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l[:] = [{u"\0" : 1}]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l[:] = [{"\0" : 1}]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using l[:] = [{"abc" : {%s : 1}}]
! l[:] = [{"abc" : {1 : 1}}]:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l[:] = [{"abc" : {u"\0" : 1}}]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l[:] = [{"abc" : {"\0" : 1}}]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using l[:] = [{"abc" : Mapping({%s : 1})}]
! l[:] = [{"abc" : Mapping({1 : 1})}]:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l[:] = [{"abc" : Mapping({u"\0" : 1})}]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l[:] = [{"abc" : Mapping({"\0" : 1})}]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using l[:] = [{"abc" : %s}]
! l[:] = [{"abc" : FailingIter()}]:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [{"abc" : FailingIterNext()}]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using l[:] = [{"abc" : %s}]
! l[:] = [{"abc" : None}]:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [{"abc" : {"": 1}}]:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l[:] = [{"abc" : {u"": 1}}]:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l[:] = [{"abc" : FailingMapping()}]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l[:] = [{"abc" : FailingMappingKey()}]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing StringToChars using l[:] = [Mapping({%s : 1})]
! l[:] = [Mapping({1 : 1})]:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l[:] = [Mapping({u"\0" : 1})]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l[:] = [Mapping({"\0" : 1})]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using l[:] = [Mapping({"abc" : {%s : 1}})]
! l[:] = [Mapping({"abc" : {1 : 1}})]:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l[:] = [Mapping({"abc" : {u"\0" : 1}})]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l[:] = [Mapping({"abc" : {"\0" : 1}})]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using l[:] = [Mapping({"abc" : Mapping({%s : 1})})]
! l[:] = [Mapping({"abc" : Mapping({1 : 1})})]:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l[:] = [Mapping({"abc" : Mapping({u"\0" : 1})})]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l[:] = [Mapping({"abc" : Mapping({"\0" : 1})})]:(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using l[:] = [Mapping({"abc" : %s})]
! l[:] = [Mapping({"abc" : FailingIter()})]:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [Mapping({"abc" : FailingIterNext()})]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using l[:] = [Mapping({"abc" : %s})]
! l[:] = [Mapping({"abc" : None})]:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [Mapping({"abc" : {"": 1}})]:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l[:] = [Mapping({"abc" : {u"": 1}})]:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l[:] = [Mapping({"abc" : FailingMapping()})]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l[:] = [Mapping({"abc" : FailingMappingKey()})]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing *Iter* using l[:] = [%s]
! l[:] = [FailingIter()]:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [FailingIterNext()]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using l[:] = [%s]
! l[:] = [None]:(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l[:] = [{"": 1}]:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l[:] = [{u"": 1}]:(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l[:] = [FailingMapping()]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l[:] = [FailingMappingKey()]:(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >> ListConcatInPlace
  >>> Testing StringToChars using l.extend([{%s : 1}])
! l.extend([{1 : 1}]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l.extend([{u"\0" : 1}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l.extend([{"\0" : 1}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using l.extend([{"abc" : {%s : 1}}])
! l.extend([{"abc" : {1 : 1}}]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l.extend([{"abc" : {u"\0" : 1}}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l.extend([{"abc" : {"\0" : 1}}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using l.extend([{"abc" : Mapping({%s : 1})}])
! l.extend([{"abc" : Mapping({1 : 1})}]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l.extend([{"abc" : Mapping({u"\0" : 1})}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l.extend([{"abc" : Mapping({"\0" : 1})}]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using l.extend([{"abc" : %s}])
! l.extend([{"abc" : FailingIter()}]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([{"abc" : FailingIterNext()}]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using l.extend([{"abc" : %s}])
! l.extend([{"abc" : None}]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([{"abc" : {"": 1}}]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l.extend([{"abc" : {u"": 1}}]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l.extend([{"abc" : FailingMapping()}]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l.extend([{"abc" : FailingMappingKey()}]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing StringToChars using l.extend([Mapping({%s : 1})])
! l.extend([Mapping({1 : 1})]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l.extend([Mapping({u"\0" : 1})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l.extend([Mapping({"\0" : 1})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using l.extend([Mapping({"abc" : {%s : 1}})])
! l.extend([Mapping({"abc" : {1 : 1}})]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l.extend([Mapping({"abc" : {u"\0" : 1}})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l.extend([Mapping({"abc" : {"\0" : 1}})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using l.extend([Mapping({"abc" : Mapping({%s : 1})})])
! l.extend([Mapping({"abc" : Mapping({1 : 1})})]):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! l.extend([Mapping({"abc" : Mapping({u"\0" : 1})})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! l.extend([Mapping({"abc" : Mapping({"\0" : 1})})]):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using l.extend([Mapping({"abc" : %s})])
! l.extend([Mapping({"abc" : FailingIter()})]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([Mapping({"abc" : FailingIterNext()})]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using l.extend([Mapping({"abc" : %s})])
! l.extend([Mapping({"abc" : None})]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([Mapping({"abc" : {"": 1}})]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l.extend([Mapping({"abc" : {u"": 1}})]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l.extend([Mapping({"abc" : FailingMapping()})]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l.extend([Mapping({"abc" : FailingMappingKey()})]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing *Iter* using l.extend([%s])
! l.extend([FailingIter()]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([FailingIterNext()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using l.extend([%s])
! l.extend([None]):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! l.extend([{"": 1}]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l.extend([{u"": 1}]):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! l.extend([FailingMapping()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l.extend([FailingMappingKey()]):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >> ListSetattr
! del l.locked:(<type 'exceptions.AttributeError'>, AttributeError('cannot delete vim.List attributes',))
! l.locked = FailingTrue():(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! l.xxx = True:(<type 'exceptions.AttributeError'>, AttributeError('cannot set this attribute',))
  > Function
  >> FunctionConstructor
! vim.Function("123"):(<type 'exceptions.ValueError'>, ValueError('unnamed function does not exist',))
! vim.Function("xxx_non_existent_function_xxx"):(<type 'exceptions.ValueError'>, ValueError('function does not exist',))
  vim.Function("xxx#non#existent#function#xxx"):NOT FAILED
  >> FunctionCall
  >>> Testing StringToChars using f({%s : 1})
! f({1 : 1}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! f({u"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! f({"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using f({"abc" : {%s : 1}})
! f({"abc" : {1 : 1}}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! f({"abc" : {u"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! f({"abc" : {"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using f({"abc" : Mapping({%s : 1})})
! f({"abc" : Mapping({1 : 1})}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! f({"abc" : Mapping({u"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! f({"abc" : Mapping({"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using f({"abc" : %s})
! f({"abc" : FailingIter()}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! f({"abc" : FailingIterNext()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using f({"abc" : %s})
! f({"abc" : None}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! f({"abc" : {"": 1}}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! f({"abc" : {u"": 1}}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! f({"abc" : FailingMapping()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! f({"abc" : FailingMappingKey()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing StringToChars using f(Mapping({%s : 1}))
! f(Mapping({1 : 1})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! f(Mapping({u"\0" : 1})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! f(Mapping({"\0" : 1})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using f(Mapping({"abc" : {%s : 1}}))
! f(Mapping({"abc" : {1 : 1}})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! f(Mapping({"abc" : {u"\0" : 1}})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! f(Mapping({"abc" : {"\0" : 1}})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using f(Mapping({"abc" : Mapping({%s : 1})}))
! f(Mapping({"abc" : Mapping({1 : 1})})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! f(Mapping({"abc" : Mapping({u"\0" : 1})})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! f(Mapping({"abc" : Mapping({"\0" : 1})})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using f(Mapping({"abc" : %s}))
! f(Mapping({"abc" : FailingIter()})):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! f(Mapping({"abc" : FailingIterNext()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using f(Mapping({"abc" : %s}))
! f(Mapping({"abc" : None})):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! f(Mapping({"abc" : {"": 1}})):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! f(Mapping({"abc" : {u"": 1}})):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! f(Mapping({"abc" : FailingMapping()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! f(Mapping({"abc" : FailingMappingKey()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing *Iter* using f(%s)
! f(FailingIter()):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! f(FailingIterNext()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using f(%s)
! f(None):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! f({"": 1}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! f({u"": 1}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! f(FailingMapping()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! f(FailingMappingKey()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing StringToChars using fd(self={%s : 1})
! fd(self={1 : 1}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! fd(self={u"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! fd(self={"\0" : 1}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using fd(self={"abc" : {%s : 1}})
! fd(self={"abc" : {1 : 1}}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! fd(self={"abc" : {u"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! fd(self={"abc" : {"\0" : 1}}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using fd(self={"abc" : Mapping({%s : 1})})
! fd(self={"abc" : Mapping({1 : 1})}):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! fd(self={"abc" : Mapping({u"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! fd(self={"abc" : Mapping({"\0" : 1})}):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using fd(self={"abc" : %s})
! fd(self={"abc" : FailingIter()}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! fd(self={"abc" : FailingIterNext()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using fd(self={"abc" : %s})
! fd(self={"abc" : None}):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! fd(self={"abc" : {"": 1}}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! fd(self={"abc" : {u"": 1}}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! fd(self={"abc" : FailingMapping()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! fd(self={"abc" : FailingMappingKey()}):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing StringToChars using fd(self=Mapping({%s : 1}))
! fd(self=Mapping({1 : 1})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! fd(self=Mapping({u"\0" : 1})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! fd(self=Mapping({"\0" : 1})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using fd(self=Mapping({"abc" : {%s : 1}}))
! fd(self=Mapping({"abc" : {1 : 1}})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! fd(self=Mapping({"abc" : {u"\0" : 1}})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! fd(self=Mapping({"abc" : {"\0" : 1}})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing StringToChars using fd(self=Mapping({"abc" : Mapping({%s : 1})}))
! fd(self=Mapping({"abc" : Mapping({1 : 1})})):(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! fd(self=Mapping({"abc" : Mapping({u"\0" : 1})})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
! fd(self=Mapping({"abc" : Mapping({"\0" : 1})})):(<type 'exceptions.TypeError'>, TypeError('expected string without null bytes',))
  <<< Finished
  >>> Testing *Iter* using fd(self=Mapping({"abc" : %s}))
! fd(self=Mapping({"abc" : FailingIter()})):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! fd(self=Mapping({"abc" : FailingIterNext()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyObject using fd(self=Mapping({"abc" : %s}))
! fd(self=Mapping({"abc" : None})):(<type 'exceptions.TypeError'>, TypeError('unable to convert to vim structure',))
! fd(self=Mapping({"abc" : {"": 1}})):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! fd(self=Mapping({"abc" : {u"": 1}})):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! fd(self=Mapping({"abc" : FailingMapping()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! fd(self=Mapping({"abc" : FailingMappingKey()})):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing *Iter* using fd(self=%s)
! fd(self=FailingIter()):(<type 'exceptions.TypeError'>, TypeError('unable to convert object to vim dictionary',))
! fd(self=FailingIterNext()):(<type 'exceptions.TypeError'>, TypeError('unable to convert object to vim dictionary',))
  <<< Finished
  >>> Testing ConvertFromPyObject using fd(self=%s)
! fd(self=None):(<type 'exceptions.TypeError'>, TypeError('unable to convert object to vim dictionary',))
! fd(self={"": 1}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! fd(self={u"": 1}):(<type 'exceptions.ValueError'>, ValueError('empty keys are not allowed',))
! fd(self=FailingMapping()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
! fd(self=FailingMappingKey()):(<type 'exceptions.NotImplementedError'>, NotImplementedError())
  <<< Finished
  >>> Testing ConvertFromPyMapping using fd(self=%s)
! fd(self=[]):(<type 'exceptions.TypeError'>, TypeError('unable to convert object to vim dictionary',))
  <<< Finished
  > TabPage
  >> TabPageAttr
! vim.current.tabpage.xxx:(<type 'exceptions.AttributeError'>, AttributeError('xxx',))
  > TabList
  >> TabListItem
! vim.tabpages[1000]:(<type 'exceptions.IndexError'>, IndexError('no such tab page',))
  > Window
  >> WindowAttr
! vim.current.window.xxx:(<type 'exceptions.AttributeError'>, AttributeError('xxx',))
  >> WindowSetattr
! vim.current.window.buffer = 0:(<type 'exceptions.TypeError'>, TypeError('readonly attribute',))
! vim.current.window.cursor = (100000000, 100000000):(<class 'vim.error'>, error('cursor position outside buffer',))
! vim.current.window.cursor = True:(<type 'exceptions.TypeError'>, TypeError('argument must be 2-item sequence, not bool',))
! vim.current.window.height = "abc":(<type 'exceptions.TypeError'>, TypeError('an integer is required',))
! vim.current.window.width  = "abc":(<type 'exceptions.TypeError'>, TypeError('an integer is required',))
! vim.current.window.xxxxxx = True:(<type 'exceptions.AttributeError'>, AttributeError('xxxxxx',))
  > WinList
  >> WinListItem
! vim.windows[1000]:(<type 'exceptions.IndexError'>, IndexError('no such window',))
  > Buffer
  >> StringToLine (indirect)
! vim.current.buffer[0] = "\na":(<class 'vim.error'>, error('string cannot contain newlines',))
  >> SetBufferLine (indirect)
! vim.current.buffer[0] = True:(<type 'exceptions.TypeError'>, TypeError('bad argument type for built-in operation',))
  >> SetBufferLines (indirect)
! vim.current.buffer[:] = True:(<type 'exceptions.TypeError'>, TypeError('bad argument type for built-in operation',))
! vim.current.buffer[:] = ["\na", "bc"]:(<class 'vim.error'>, error('string cannot contain newlines',))
  >> InsertBufferLines (indirect)
! vim.current.buffer.append(None):(<type 'exceptions.TypeError'>, TypeError('bad argument type for built-in operation',))
! vim.current.buffer.append(["\na", "bc"]):(<class 'vim.error'>, error('string cannot contain newlines',))
! vim.current.buffer.append("\nbc"):(<class 'vim.error'>, error('string cannot contain newlines',))
  >> RBItem
! vim.current.buffer[100000000]:(<type 'exceptions.IndexError'>, IndexError('line number out of range',))
  >> RBAsItem
! vim.current.buffer[100000000] = "":(<type 'exceptions.IndexError'>, IndexError('line number out of range',))
  >> BufferAttr
! vim.current.buffer.xxx:(<type 'exceptions.AttributeError'>, AttributeError('xxx',))
  >> BufferSetattr
! vim.current.buffer.name = True:(<type 'exceptions.TypeError'>, TypeError('object must be string',))
! vim.current.buffer.xxx = True:(<type 'exceptions.AttributeError'>, AttributeError('xxx',))
  >> BufferMark
! vim.current.buffer.mark(0):(<type 'exceptions.TypeError'>, TypeError('must be string, not int',))
! vim.current.buffer.mark("abc"):(<type 'exceptions.ValueError'>, ValueError('mark name must be a single character',))
! vim.current.buffer.mark("!"):(<class 'vim.error'>, error('invalid mark name',))
  >> BufferRange
! vim.current.buffer.range(1, 2, 3):(<type 'exceptions.TypeError'>, TypeError('function takes exactly 2 arguments (3 given)',))
  > BufMap
  >> BufMapItem
! vim.buffers[None]:(<type 'exceptions.TypeError'>, TypeError('key must be integer',))
! vim.buffers[100000000]:(<type 'exceptions.KeyError'>, KeyError(100000000,))
  > Current
  >> CurrentGetattr
! vim.current.xxx:(<type 'exceptions.AttributeError'>, AttributeError('xxx',))
  >> CurrentSetattr
! vim.current.line = True:(<type 'exceptions.TypeError'>, TypeError('bad argument type for built-in operation',))
! vim.current.buffer = True:(<type 'exceptions.TypeError'>, TypeError('expected vim.Buffer object',))
! vim.current.window = True:(<type 'exceptions.TypeError'>, TypeError('expected vim.Window object',))
! vim.current.tabpage = True:(<type 'exceptions.TypeError'>, TypeError('expected vim.TabPage object',))
! vim.current.xxx = True:(<type 'exceptions.AttributeError'>, AttributeError('xxx',))
  2,xx
  before
  after
! vim.command("throw 'abc'"):(<class 'vim.error'>, error('abc',))
! Exe("throw 'def'"):(<class 'vim.error'>, error('def',))
! vim.eval("Exe('throw ''ghi''')"):(<class 'vim.error'>, error('ghi',))
! vim.eval("Exe('echoerr ''jkl''')"):(<class 'vim.error'>, error('Vim(echoerr):jkl',))
! vim.eval("Exe('xxx_non_existent_command_xxx')"):(<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
! vim.bindeval("Exe('xxx_non_existent_command_xxx')"):(<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
--- 437,1094 ----
  test86.in
  > Output
  >> OutputSetattr
! del sys.stdout.softspace:AttributeError:("can't delete OutputObject attributes",)
! sys.stdout.softspace = []:TypeError:('softspace must be an integer',)
! sys.stdout.attr = None:AttributeError:('invalid attribute',)
  >> OutputWrite
! sys.stdout.write(None):TypeError:('coercing to Unicode: need string or buffer, NoneType found',)
  >> OutputWriteLines
! sys.stdout.writelines(None):TypeError:("'NoneType' object is not iterable",)
! sys.stdout.writelines([1]):TypeError:('writelines() requires list of strings',)
  > VimCommand
! vim.command(1):TypeError:('must be string, not int',)
  > VimToPython
  > VimEval
! vim.eval(1):TypeError:('must be string, not int',)
  > VimEvalPy
! vim.bindeval(1):TypeError:('must be string, not int',)
  > VimStrwidth
! vim.strwidth(1):TypeError:('must be string, not int',)
  > Dictionary
  >> DictionaryConstructor
! vim.Dictionary("abc"):ValueError:('expected sequence element of size 2',)
  >> DictionarySetattr
! del d.locked:AttributeError:('cannot delete vim.Dictionary attributes',)
! d.locked = FailingTrue():NotImplementedError:()
! vim.vvars.locked = False:TypeError:('cannot modify fixed dictionary',)
! d.scope = True:AttributeError:('cannot set this attribute',)
! d.xxx = True:AttributeError:('cannot set this attribute',)
  >> _DictionaryItem
! d.get("a", 2, 3):TypeError:('function takes at most 2 arguments (3 given)',)
  >>> Testing StringToChars using d.get(%s)
! d.get(1):TypeError:('object must be string',)
! d.get(u"\0"):TypeError:('expected string without null bytes',)
! d.get("\0"):TypeError:('expected string without null bytes',)
  <<< Finished
! d.pop("a"):KeyError:('a',)
! dl.pop("a"):error:('dict is locked',)
  >> DictionaryIterNext
! for i in ned: ned["a"] = 1:RuntimeError:('hashtab changed during iteration',)
  >> DictionaryAssItem
! dl["b"] = 1:error:('dict is locked',)
  >>> Testing StringToChars using d[%s] = 1
! d[1] = 1:TypeError:('object must be string',)
! d[u"\0"] = 1:TypeError:('expected string without null bytes',)
! d["\0"] = 1:TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d["a"] = {%s : 1}
! d["a"] = {1 : 1}:TypeError:('object must be string',)
! d["a"] = {u"\0" : 1}:TypeError:('expected string without null bytes',)
! d["a"] = {"\0" : 1}:TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d["a"] = {"abc" : {%s : 1}}
! d["a"] = {"abc" : {1 : 1}}:TypeError:('object must be string',)
! d["a"] = {"abc" : {u"\0" : 1}}:TypeError:('expected string without null bytes',)
! d["a"] = {"abc" : {"\0" : 1}}:TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d["a"] = {"abc" : Mapping({%s : 1})}
! d["a"] = {"abc" : Mapping({1 : 1})}:TypeError:('object must be string',)
! d["a"] = {"abc" : Mapping({u"\0" : 1})}:TypeError:('expected string without null bytes',)
! d["a"] = {"abc" : Mapping({"\0" : 1})}:TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using d["a"] = {"abc" : %s}
! d["a"] = {"abc" : FailingIter()}:TypeError:('unable to convert to vim structure',)
! d["a"] = {"abc" : FailingIterNext()}:NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using d["a"] = {"abc" : %s}
! d["a"] = {"abc" : None}:TypeError:('unable to convert to vim structure',)
! d["a"] = {"abc" : {"": 1}}:ValueError:('empty keys are not allowed',)
! d["a"] = {"abc" : {u"": 1}}:ValueError:('empty keys are not allowed',)
! d["a"] = {"abc" : FailingMapping()}:NotImplementedError:()
! d["a"] = {"abc" : FailingMappingKey()}:NotImplementedError:()
  <<< Finished
  >>> Testing StringToChars using d["a"] = Mapping({%s : 1})
! d["a"] = Mapping({1 : 1}):TypeError:('object must be string',)
! d["a"] = Mapping({u"\0" : 1}):TypeError:('expected string without null bytes',)
! d["a"] = Mapping({"\0" : 1}):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d["a"] = Mapping({"abc" : {%s : 1}})
! d["a"] = Mapping({"abc" : {1 : 1}}):TypeError:('object must be string',)
! d["a"] = Mapping({"abc" : {u"\0" : 1}}):TypeError:('expected string without null bytes',)
! d["a"] = Mapping({"abc" : {"\0" : 1}}):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d["a"] = Mapping({"abc" : Mapping({%s : 1})})
! d["a"] = Mapping({"abc" : Mapping({1 : 1})}):TypeError:('object must be string',)
! d["a"] = Mapping({"abc" : Mapping({u"\0" : 1})}):TypeError:('expected string without null bytes',)
! d["a"] = Mapping({"abc" : Mapping({"\0" : 1})}):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using d["a"] = Mapping({"abc" : %s})
! d["a"] = Mapping({"abc" : FailingIter()}):TypeError:('unable to convert to vim structure',)
! d["a"] = Mapping({"abc" : FailingIterNext()}):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using d["a"] = Mapping({"abc" : %s})
! d["a"] = Mapping({"abc" : None}):TypeError:('unable to convert to vim structure',)
! d["a"] = Mapping({"abc" : {"": 1}}):ValueError:('empty keys are not allowed',)
! d["a"] = Mapping({"abc" : {u"": 1}}):ValueError:('empty keys are not allowed',)
! d["a"] = Mapping({"abc" : FailingMapping()}):NotImplementedError:()
! d["a"] = Mapping({"abc" : FailingMappingKey()}):NotImplementedError:()
  <<< Finished
  >>> Testing *Iter* using d["a"] = %s
! d["a"] = FailingIter():TypeError:('unable to convert to vim structure',)
! d["a"] = FailingIterNext():NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using d["a"] = %s
! d["a"] = None:TypeError:('unable to convert to vim structure',)
! d["a"] = {"": 1}:ValueError:('empty keys are not allowed',)
! d["a"] = {u"": 1}:ValueError:('empty keys are not allowed',)
! d["a"] = FailingMapping():NotImplementedError:()
! d["a"] = FailingMappingKey():NotImplementedError:()
  <<< Finished
  >> DictionaryUpdate
  >>> kwargs
  >>> iter
! d.update(FailingMapping()):NotImplementedError:()
! d.update([FailingIterNext()]):NotImplementedError:()
  >>> Testing StringToChars using d.update({%s : 1})
! d.update({1 : 1}):TypeError:('object must be string',)
! d.update({u"\0" : 1}):TypeError:('expected string without null bytes',)
! d.update({"\0" : 1}):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d.update({"abc" : {%s : 1}})
! d.update({"abc" : {1 : 1}}):TypeError:('object must be string',)
! d.update({"abc" : {u"\0" : 1}}):TypeError:('expected string without null bytes',)
! d.update({"abc" : {"\0" : 1}}):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d.update({"abc" : Mapping({%s : 1})})
! d.update({"abc" : Mapping({1 : 1})}):TypeError:('object must be string',)
! d.update({"abc" : Mapping({u"\0" : 1})}):TypeError:('expected string without null bytes',)
! d.update({"abc" : Mapping({"\0" : 1})}):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using d.update({"abc" : %s})
! d.update({"abc" : FailingIter()}):TypeError:('unable to convert to vim structure',)
! d.update({"abc" : FailingIterNext()}):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using d.update({"abc" : %s})
! d.update({"abc" : None}):TypeError:('unable to convert to vim structure',)
! d.update({"abc" : {"": 1}}):ValueError:('empty keys are not allowed',)
! d.update({"abc" : {u"": 1}}):ValueError:('empty keys are not allowed',)
! d.update({"abc" : FailingMapping()}):NotImplementedError:()
! d.update({"abc" : FailingMappingKey()}):NotImplementedError:()
  <<< Finished
  >>> Testing StringToChars using d.update(Mapping({%s : 1}))
! d.update(Mapping({1 : 1})):TypeError:('object must be string',)
! d.update(Mapping({u"\0" : 1})):TypeError:('expected string without null bytes',)
! d.update(Mapping({"\0" : 1})):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d.update(Mapping({"abc" : {%s : 1}}))
! d.update(Mapping({"abc" : {1 : 1}})):TypeError:('object must be string',)
! d.update(Mapping({"abc" : {u"\0" : 1}})):TypeError:('expected string without null bytes',)
! d.update(Mapping({"abc" : {"\0" : 1}})):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d.update(Mapping({"abc" : Mapping({%s : 1})}))
! d.update(Mapping({"abc" : Mapping({1 : 1})})):TypeError:('object must be string',)
! d.update(Mapping({"abc" : Mapping({u"\0" : 1})})):TypeError:('expected string without null bytes',)
! d.update(Mapping({"abc" : Mapping({"\0" : 1})})):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using d.update(Mapping({"abc" : %s}))
! d.update(Mapping({"abc" : FailingIter()})):TypeError:('unable to convert to vim structure',)
! d.update(Mapping({"abc" : FailingIterNext()})):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using d.update(Mapping({"abc" : %s}))
! d.update(Mapping({"abc" : None})):TypeError:('unable to convert to vim structure',)
! d.update(Mapping({"abc" : {"": 1}})):ValueError:('empty keys are not allowed',)
! d.update(Mapping({"abc" : {u"": 1}})):ValueError:('empty keys are not allowed',)
! d.update(Mapping({"abc" : FailingMapping()})):NotImplementedError:()
! d.update(Mapping({"abc" : FailingMappingKey()})):NotImplementedError:()
  <<< Finished
  >>> Testing *Iter* using d.update(%s)
! d.update(FailingIter()):NotImplementedError:()
! d.update(FailingIterNext()):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using d.update(%s)
! d.update(None):TypeError:("'NoneType' object is not iterable",)
! d.update({"": 1}):ValueError:('empty keys are not allowed',)
! d.update({u"": 1}):ValueError:('empty keys are not allowed',)
! d.update(FailingMapping()):NotImplementedError:()
! d.update(FailingMappingKey()):NotImplementedError:()
  <<< Finished
  >>> Testing StringToChars using d.update(((%s, 0),))
! d.update(((1, 0),)):TypeError:('object must be string',)
! d.update(((u"\0", 0),)):TypeError:('expected string without null bytes',)
! d.update((("\0", 0),)):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d.update((("a", {%s : 1}),))
! d.update((("a", {1 : 1}),)):TypeError:('object must be string',)
! d.update((("a", {u"\0" : 1}),)):TypeError:('expected string without null bytes',)
! d.update((("a", {"\0" : 1}),)):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d.update((("a", {"abc" : {%s : 1}}),))
! d.update((("a", {"abc" : {1 : 1}}),)):TypeError:('object must be string',)
! d.update((("a", {"abc" : {u"\0" : 1}}),)):TypeError:('expected string without null bytes',)
! d.update((("a", {"abc" : {"\0" : 1}}),)):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d.update((("a", {"abc" : Mapping({%s : 1})}),))
! d.update((("a", {"abc" : Mapping({1 : 1})}),)):TypeError:('object must be string',)
! d.update((("a", {"abc" : Mapping({u"\0" : 1})}),)):TypeError:('expected string without null bytes',)
! d.update((("a", {"abc" : Mapping({"\0" : 1})}),)):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using d.update((("a", {"abc" : %s}),))
! d.update((("a", {"abc" : FailingIter()}),)):TypeError:('unable to convert to vim structure',)
! d.update((("a", {"abc" : FailingIterNext()}),)):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using d.update((("a", {"abc" : %s}),))
! d.update((("a", {"abc" : None}),)):TypeError:('unable to convert to vim structure',)
! d.update((("a", {"abc" : {"": 1}}),)):ValueError:('empty keys are not allowed',)
! d.update((("a", {"abc" : {u"": 1}}),)):ValueError:('empty keys are not allowed',)
! d.update((("a", {"abc" : FailingMapping()}),)):NotImplementedError:()
! d.update((("a", {"abc" : FailingMappingKey()}),)):NotImplementedError:()
  <<< Finished
  >>> Testing StringToChars using d.update((("a", Mapping({%s : 1})),))
! d.update((("a", Mapping({1 : 1})),)):TypeError:('object must be string',)
! d.update((("a", Mapping({u"\0" : 1})),)):TypeError:('expected string without null bytes',)
! d.update((("a", Mapping({"\0" : 1})),)):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d.update((("a", Mapping({"abc" : {%s : 1}})),))
! d.update((("a", Mapping({"abc" : {1 : 1}})),)):TypeError:('object must be string',)
! d.update((("a", Mapping({"abc" : {u"\0" : 1}})),)):TypeError:('expected string without null bytes',)
! d.update((("a", Mapping({"abc" : {"\0" : 1}})),)):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using d.update((("a", Mapping({"abc" : Mapping({%s : 1})})),))
! d.update((("a", Mapping({"abc" : Mapping({1 : 1})})),)):TypeError:('object must be string',)
! d.update((("a", Mapping({"abc" : Mapping({u"\0" : 1})})),)):TypeError:('expected string without null bytes',)
! d.update((("a", Mapping({"abc" : Mapping({"\0" : 1})})),)):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using d.update((("a", Mapping({"abc" : %s})),))
! d.update((("a", Mapping({"abc" : FailingIter()})),)):TypeError:('unable to convert to vim structure',)
! d.update((("a", Mapping({"abc" : FailingIterNext()})),)):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using d.update((("a", Mapping({"abc" : %s})),))
! d.update((("a", Mapping({"abc" : None})),)):TypeError:('unable to convert to vim structure',)
! d.update((("a", Mapping({"abc" : {"": 1}})),)):ValueError:('empty keys are not allowed',)
! d.update((("a", Mapping({"abc" : {u"": 1}})),)):ValueError:('empty keys are not allowed',)
! d.update((("a", Mapping({"abc" : FailingMapping()})),)):NotImplementedError:()
! d.update((("a", Mapping({"abc" : FailingMappingKey()})),)):NotImplementedError:()
  <<< Finished
  >>> Testing *Iter* using d.update((("a", %s),))
! d.update((("a", FailingIter()),)):TypeError:('unable to convert to vim structure',)
! d.update((("a", FailingIterNext()),)):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using d.update((("a", %s),))
! d.update((("a", None),)):TypeError:('unable to convert to vim structure',)
! d.update((("a", {"": 1}),)):ValueError:('empty keys are not allowed',)
! d.update((("a", {u"": 1}),)):ValueError:('empty keys are not allowed',)
! d.update((("a", FailingMapping()),)):NotImplementedError:()
! d.update((("a", FailingMappingKey()),)):NotImplementedError:()
  <<< Finished
  >> DictionaryPopItem
! d.popitem(1, 2):TypeError:('popitem() takes no arguments (2 given)',)
  >> DictionaryHasKey
! d.has_key():TypeError:('function takes exactly 1 argument (0 given)',)
  > List
  >> ListConstructor
! vim.List(1, 2):TypeError:('function takes at most 1 argument (2 given)',)
! vim.List(a=1):TypeError:('list constructor does not accept keyword arguments',)
  >>> Testing StringToChars using vim.List([{%s : 1}])
! vim.List([{1 : 1}]):TypeError:('object must be string',)
! vim.List([{u"\0" : 1}]):TypeError:('expected string without null bytes',)
! vim.List([{"\0" : 1}]):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using vim.List([{"abc" : {%s : 1}}])
! vim.List([{"abc" : {1 : 1}}]):TypeError:('object must be string',)
! vim.List([{"abc" : {u"\0" : 1}}]):TypeError:('expected string without null bytes',)
! vim.List([{"abc" : {"\0" : 1}}]):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using vim.List([{"abc" : Mapping({%s : 1})}])
! vim.List([{"abc" : Mapping({1 : 1})}]):TypeError:('object must be string',)
! vim.List([{"abc" : Mapping({u"\0" : 1})}]):TypeError:('expected string without null bytes',)
! vim.List([{"abc" : Mapping({"\0" : 1})}]):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using vim.List([{"abc" : %s}])
! vim.List([{"abc" : FailingIter()}]):TypeError:('unable to convert to vim structure',)
! vim.List([{"abc" : FailingIterNext()}]):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using vim.List([{"abc" : %s}])
! vim.List([{"abc" : None}]):TypeError:('unable to convert to vim structure',)
! vim.List([{"abc" : {"": 1}}]):ValueError:('empty keys are not allowed',)
! vim.List([{"abc" : {u"": 1}}]):ValueError:('empty keys are not allowed',)
! vim.List([{"abc" : FailingMapping()}]):NotImplementedError:()
! vim.List([{"abc" : FailingMappingKey()}]):NotImplementedError:()
  <<< Finished
  >>> Testing StringToChars using vim.List([Mapping({%s : 1})])
! vim.List([Mapping({1 : 1})]):TypeError:('object must be string',)
! vim.List([Mapping({u"\0" : 1})]):TypeError:('expected string without null bytes',)
! vim.List([Mapping({"\0" : 1})]):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using vim.List([Mapping({"abc" : {%s : 1}})])
! vim.List([Mapping({"abc" : {1 : 1}})]):TypeError:('object must be string',)
! vim.List([Mapping({"abc" : {u"\0" : 1}})]):TypeError:('expected string without null bytes',)
! vim.List([Mapping({"abc" : {"\0" : 1}})]):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using vim.List([Mapping({"abc" : Mapping({%s : 1})})])
! vim.List([Mapping({"abc" : Mapping({1 : 1})})]):TypeError:('object must be string',)
! vim.List([Mapping({"abc" : Mapping({u"\0" : 1})})]):TypeError:('expected string without null bytes',)
! vim.List([Mapping({"abc" : Mapping({"\0" : 1})})]):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using vim.List([Mapping({"abc" : %s})])
! vim.List([Mapping({"abc" : FailingIter()})]):TypeError:('unable to convert to vim structure',)
! vim.List([Mapping({"abc" : FailingIterNext()})]):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using vim.List([Mapping({"abc" : %s})])
! vim.List([Mapping({"abc" : None})]):TypeError:('unable to convert to vim structure',)
! vim.List([Mapping({"abc" : {"": 1}})]):ValueError:('empty keys are not allowed',)
! vim.List([Mapping({"abc" : {u"": 1}})]):ValueError:('empty keys are not allowed',)
! vim.List([Mapping({"abc" : FailingMapping()})]):NotImplementedError:()
! vim.List([Mapping({"abc" : FailingMappingKey()})]):NotImplementedError:()
  <<< Finished
  >>> Testing *Iter* using vim.List([%s])
! vim.List([FailingIter()]):TypeError:('unable to convert to vim structure',)
! vim.List([FailingIterNext()]):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using vim.List([%s])
! vim.List([None]):TypeError:('unable to convert to vim structure',)
! vim.List([{"": 1}]):ValueError:('empty keys are not allowed',)
! vim.List([{u"": 1}]):ValueError:('empty keys are not allowed',)
! vim.List([FailingMapping()]):NotImplementedError:()
! vim.List([FailingMappingKey()]):NotImplementedError:()
  <<< Finished
  >> ListItem
! l[1000]:IndexError:('list index out of range',)
  >> ListAssItem
! ll[1] = 2:error:('list is locked',)
! l[1000] = 3:IndexError:('list index out of range',)
  >> ListAssSlice
! ll[1:100] = "abc":error:('list is locked',)
  >>> Testing StringToChars using l[:] = [{%s : 1}]
! l[:] = [{1 : 1}]:TypeError:('object must be string',)
! l[:] = [{u"\0" : 1}]:TypeError:('expected string without null bytes',)
! l[:] = [{"\0" : 1}]:TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using l[:] = [{"abc" : {%s : 1}}]
! l[:] = [{"abc" : {1 : 1}}]:TypeError:('object must be string',)
! l[:] = [{"abc" : {u"\0" : 1}}]:TypeError:('expected string without null bytes',)
! l[:] = [{"abc" : {"\0" : 1}}]:TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using l[:] = [{"abc" : Mapping({%s : 1})}]
! l[:] = [{"abc" : Mapping({1 : 1})}]:TypeError:('object must be string',)
! l[:] = [{"abc" : Mapping({u"\0" : 1})}]:TypeError:('expected string without null bytes',)
! l[:] = [{"abc" : Mapping({"\0" : 1})}]:TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using l[:] = [{"abc" : %s}]
! l[:] = [{"abc" : FailingIter()}]:TypeError:('unable to convert to vim structure',)
! l[:] = [{"abc" : FailingIterNext()}]:NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using l[:] = [{"abc" : %s}]
! l[:] = [{"abc" : None}]:TypeError:('unable to convert to vim structure',)
! l[:] = [{"abc" : {"": 1}}]:ValueError:('empty keys are not allowed',)
! l[:] = [{"abc" : {u"": 1}}]:ValueError:('empty keys are not allowed',)
! l[:] = [{"abc" : FailingMapping()}]:NotImplementedError:()
! l[:] = [{"abc" : FailingMappingKey()}]:NotImplementedError:()
  <<< Finished
  >>> Testing StringToChars using l[:] = [Mapping({%s : 1})]
! l[:] = [Mapping({1 : 1})]:TypeError:('object must be string',)
! l[:] = [Mapping({u"\0" : 1})]:TypeError:('expected string without null bytes',)
! l[:] = [Mapping({"\0" : 1})]:TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using l[:] = [Mapping({"abc" : {%s : 1}})]
! l[:] = [Mapping({"abc" : {1 : 1}})]:TypeError:('object must be string',)
! l[:] = [Mapping({"abc" : {u"\0" : 1}})]:TypeError:('expected string without null bytes',)
! l[:] = [Mapping({"abc" : {"\0" : 1}})]:TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using l[:] = [Mapping({"abc" : Mapping({%s : 1})})]
! l[:] = [Mapping({"abc" : Mapping({1 : 1})})]:TypeError:('object must be string',)
! l[:] = [Mapping({"abc" : Mapping({u"\0" : 1})})]:TypeError:('expected string without null bytes',)
! l[:] = [Mapping({"abc" : Mapping({"\0" : 1})})]:TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using l[:] = [Mapping({"abc" : %s})]
! l[:] = [Mapping({"abc" : FailingIter()})]:TypeError:('unable to convert to vim structure',)
! l[:] = [Mapping({"abc" : FailingIterNext()})]:NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using l[:] = [Mapping({"abc" : %s})]
! l[:] = [Mapping({"abc" : None})]:TypeError:('unable to convert to vim structure',)
! l[:] = [Mapping({"abc" : {"": 1}})]:ValueError:('empty keys are not allowed',)
! l[:] = [Mapping({"abc" : {u"": 1}})]:ValueError:('empty keys are not allowed',)
! l[:] = [Mapping({"abc" : FailingMapping()})]:NotImplementedError:()
! l[:] = [Mapping({"abc" : FailingMappingKey()})]:NotImplementedError:()
  <<< Finished
  >>> Testing *Iter* using l[:] = [%s]
! l[:] = [FailingIter()]:TypeError:('unable to convert to vim structure',)
! l[:] = [FailingIterNext()]:NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using l[:] = [%s]
! l[:] = [None]:TypeError:('unable to convert to vim structure',)
! l[:] = [{"": 1}]:ValueError:('empty keys are not allowed',)
! l[:] = [{u"": 1}]:ValueError:('empty keys are not allowed',)
! l[:] = [FailingMapping()]:NotImplementedError:()
! l[:] = [FailingMappingKey()]:NotImplementedError:()
  <<< Finished
  >> ListConcatInPlace
  >>> Testing StringToChars using l.extend([{%s : 1}])
! l.extend([{1 : 1}]):TypeError:('object must be string',)
! l.extend([{u"\0" : 1}]):TypeError:('expected string without null bytes',)
! l.extend([{"\0" : 1}]):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using l.extend([{"abc" : {%s : 1}}])
! l.extend([{"abc" : {1 : 1}}]):TypeError:('object must be string',)
! l.extend([{"abc" : {u"\0" : 1}}]):TypeError:('expected string without null bytes',)
! l.extend([{"abc" : {"\0" : 1}}]):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using l.extend([{"abc" : Mapping({%s : 1})}])
! l.extend([{"abc" : Mapping({1 : 1})}]):TypeError:('object must be string',)
! l.extend([{"abc" : Mapping({u"\0" : 1})}]):TypeError:('expected string without null bytes',)
! l.extend([{"abc" : Mapping({"\0" : 1})}]):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using l.extend([{"abc" : %s}])
! l.extend([{"abc" : FailingIter()}]):TypeError:('unable to convert to vim structure',)
! l.extend([{"abc" : FailingIterNext()}]):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using l.extend([{"abc" : %s}])
! l.extend([{"abc" : None}]):TypeError:('unable to convert to vim structure',)
! l.extend([{"abc" : {"": 1}}]):ValueError:('empty keys are not allowed',)
! l.extend([{"abc" : {u"": 1}}]):ValueError:('empty keys are not allowed',)
! l.extend([{"abc" : FailingMapping()}]):NotImplementedError:()
! l.extend([{"abc" : FailingMappingKey()}]):NotImplementedError:()
  <<< Finished
  >>> Testing StringToChars using l.extend([Mapping({%s : 1})])
! l.extend([Mapping({1 : 1})]):TypeError:('object must be string',)
! l.extend([Mapping({u"\0" : 1})]):TypeError:('expected string without null bytes',)
! l.extend([Mapping({"\0" : 1})]):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using l.extend([Mapping({"abc" : {%s : 1}})])
! l.extend([Mapping({"abc" : {1 : 1}})]):TypeError:('object must be string',)
! l.extend([Mapping({"abc" : {u"\0" : 1}})]):TypeError:('expected string without null bytes',)
! l.extend([Mapping({"abc" : {"\0" : 1}})]):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using l.extend([Mapping({"abc" : Mapping({%s : 1})})])
! l.extend([Mapping({"abc" : Mapping({1 : 1})})]):TypeError:('object must be string',)
! l.extend([Mapping({"abc" : Mapping({u"\0" : 1})})]):TypeError:('expected string without null bytes',)
! l.extend([Mapping({"abc" : Mapping({"\0" : 1})})]):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using l.extend([Mapping({"abc" : %s})])
! l.extend([Mapping({"abc" : FailingIter()})]):TypeError:('unable to convert to vim structure',)
! l.extend([Mapping({"abc" : FailingIterNext()})]):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using l.extend([Mapping({"abc" : %s})])
! l.extend([Mapping({"abc" : None})]):TypeError:('unable to convert to vim structure',)
! l.extend([Mapping({"abc" : {"": 1}})]):ValueError:('empty keys are not allowed',)
! l.extend([Mapping({"abc" : {u"": 1}})]):ValueError:('empty keys are not allowed',)
! l.extend([Mapping({"abc" : FailingMapping()})]):NotImplementedError:()
! l.extend([Mapping({"abc" : FailingMappingKey()})]):NotImplementedError:()
  <<< Finished
  >>> Testing *Iter* using l.extend([%s])
! l.extend([FailingIter()]):TypeError:('unable to convert to vim structure',)
! l.extend([FailingIterNext()]):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using l.extend([%s])
! l.extend([None]):TypeError:('unable to convert to vim structure',)
! l.extend([{"": 1}]):ValueError:('empty keys are not allowed',)
! l.extend([{u"": 1}]):ValueError:('empty keys are not allowed',)
! l.extend([FailingMapping()]):NotImplementedError:()
! l.extend([FailingMappingKey()]):NotImplementedError:()
  <<< Finished
  >> ListSetattr
! del l.locked:AttributeError:('cannot delete vim.List attributes',)
! l.locked = FailingTrue():NotImplementedError:()
! l.xxx = True:AttributeError:('cannot set this attribute',)
  > Function
  >> FunctionConstructor
! vim.Function("123"):ValueError:('unnamed function does not exist',)
! vim.Function("xxx_non_existent_function_xxx"):ValueError:('function does not exist',)
  vim.Function("xxx#non#existent#function#xxx"):NOT FAILED
  >> FunctionCall
  >>> Testing StringToChars using f({%s : 1})
! f({1 : 1}):TypeError:('object must be string',)
! f({u"\0" : 1}):TypeError:('expected string without null bytes',)
! f({"\0" : 1}):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using f({"abc" : {%s : 1}})
! f({"abc" : {1 : 1}}):TypeError:('object must be string',)
! f({"abc" : {u"\0" : 1}}):TypeError:('expected string without null bytes',)
! f({"abc" : {"\0" : 1}}):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using f({"abc" : Mapping({%s : 1})})
! f({"abc" : Mapping({1 : 1})}):TypeError:('object must be string',)
! f({"abc" : Mapping({u"\0" : 1})}):TypeError:('expected string without null bytes',)
! f({"abc" : Mapping({"\0" : 1})}):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using f({"abc" : %s})
! f({"abc" : FailingIter()}):TypeError:('unable to convert to vim structure',)
! f({"abc" : FailingIterNext()}):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using f({"abc" : %s})
! f({"abc" : None}):TypeError:('unable to convert to vim structure',)
! f({"abc" : {"": 1}}):ValueError:('empty keys are not allowed',)
! f({"abc" : {u"": 1}}):ValueError:('empty keys are not allowed',)
! f({"abc" : FailingMapping()}):NotImplementedError:()
! f({"abc" : FailingMappingKey()}):NotImplementedError:()
  <<< Finished
  >>> Testing StringToChars using f(Mapping({%s : 1}))
! f(Mapping({1 : 1})):TypeError:('object must be string',)
! f(Mapping({u"\0" : 1})):TypeError:('expected string without null bytes',)
! f(Mapping({"\0" : 1})):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using f(Mapping({"abc" : {%s : 1}}))
! f(Mapping({"abc" : {1 : 1}})):TypeError:('object must be string',)
! f(Mapping({"abc" : {u"\0" : 1}})):TypeError:('expected string without null bytes',)
! f(Mapping({"abc" : {"\0" : 1}})):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using f(Mapping({"abc" : Mapping({%s : 1})}))
! f(Mapping({"abc" : Mapping({1 : 1})})):TypeError:('object must be string',)
! f(Mapping({"abc" : Mapping({u"\0" : 1})})):TypeError:('expected string without null bytes',)
! f(Mapping({"abc" : Mapping({"\0" : 1})})):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using f(Mapping({"abc" : %s}))
! f(Mapping({"abc" : FailingIter()})):TypeError:('unable to convert to vim structure',)
! f(Mapping({"abc" : FailingIterNext()})):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using f(Mapping({"abc" : %s}))
! f(Mapping({"abc" : None})):TypeError:('unable to convert to vim structure',)
! f(Mapping({"abc" : {"": 1}})):ValueError:('empty keys are not allowed',)
! f(Mapping({"abc" : {u"": 1}})):ValueError:('empty keys are not allowed',)
! f(Mapping({"abc" : FailingMapping()})):NotImplementedError:()
! f(Mapping({"abc" : FailingMappingKey()})):NotImplementedError:()
  <<< Finished
  >>> Testing *Iter* using f(%s)
! f(FailingIter()):TypeError:('unable to convert to vim structure',)
! f(FailingIterNext()):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using f(%s)
! f(None):TypeError:('unable to convert to vim structure',)
! f({"": 1}):ValueError:('empty keys are not allowed',)
! f({u"": 1}):ValueError:('empty keys are not allowed',)
! f(FailingMapping()):NotImplementedError:()
! f(FailingMappingKey()):NotImplementedError:()
  <<< Finished
  >>> Testing StringToChars using fd(self={%s : 1})
! fd(self={1 : 1}):TypeError:('object must be string',)
! fd(self={u"\0" : 1}):TypeError:('expected string without null bytes',)
! fd(self={"\0" : 1}):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using fd(self={"abc" : {%s : 1}})
! fd(self={"abc" : {1 : 1}}):TypeError:('object must be string',)
! fd(self={"abc" : {u"\0" : 1}}):TypeError:('expected string without null bytes',)
! fd(self={"abc" : {"\0" : 1}}):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using fd(self={"abc" : Mapping({%s : 1})})
! fd(self={"abc" : Mapping({1 : 1})}):TypeError:('object must be string',)
! fd(self={"abc" : Mapping({u"\0" : 1})}):TypeError:('expected string without null bytes',)
! fd(self={"abc" : Mapping({"\0" : 1})}):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using fd(self={"abc" : %s})
! fd(self={"abc" : FailingIter()}):TypeError:('unable to convert to vim structure',)
! fd(self={"abc" : FailingIterNext()}):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using fd(self={"abc" : %s})
! fd(self={"abc" : None}):TypeError:('unable to convert to vim structure',)
! fd(self={"abc" : {"": 1}}):ValueError:('empty keys are not allowed',)
! fd(self={"abc" : {u"": 1}}):ValueError:('empty keys are not allowed',)
! fd(self={"abc" : FailingMapping()}):NotImplementedError:()
! fd(self={"abc" : FailingMappingKey()}):NotImplementedError:()
  <<< Finished
  >>> Testing StringToChars using fd(self=Mapping({%s : 1}))
! fd(self=Mapping({1 : 1})):TypeError:('object must be string',)
! fd(self=Mapping({u"\0" : 1})):TypeError:('expected string without null bytes',)
! fd(self=Mapping({"\0" : 1})):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using fd(self=Mapping({"abc" : {%s : 1}}))
! fd(self=Mapping({"abc" : {1 : 1}})):TypeError:('object must be string',)
! fd(self=Mapping({"abc" : {u"\0" : 1}})):TypeError:('expected string without null bytes',)
! fd(self=Mapping({"abc" : {"\0" : 1}})):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing StringToChars using fd(self=Mapping({"abc" : Mapping({%s : 1})}))
! fd(self=Mapping({"abc" : Mapping({1 : 1})})):TypeError:('object must be string',)
! fd(self=Mapping({"abc" : Mapping({u"\0" : 1})})):TypeError:('expected string without null bytes',)
! fd(self=Mapping({"abc" : Mapping({"\0" : 1})})):TypeError:('expected string without null bytes',)
  <<< Finished
  >>> Testing *Iter* using fd(self=Mapping({"abc" : %s}))
! fd(self=Mapping({"abc" : FailingIter()})):TypeError:('unable to convert to vim structure',)
! fd(self=Mapping({"abc" : FailingIterNext()})):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyObject using fd(self=Mapping({"abc" : %s}))
! fd(self=Mapping({"abc" : None})):TypeError:('unable to convert to vim structure',)
! fd(self=Mapping({"abc" : {"": 1}})):ValueError:('empty keys are not allowed',)
! fd(self=Mapping({"abc" : {u"": 1}})):ValueError:('empty keys are not allowed',)
! fd(self=Mapping({"abc" : FailingMapping()})):NotImplementedError:()
! fd(self=Mapping({"abc" : FailingMappingKey()})):NotImplementedError:()
  <<< Finished
  >>> Testing *Iter* using fd(self=%s)
! fd(self=FailingIter()):TypeError:('unable to convert object to vim dictionary',)
! fd(self=FailingIterNext()):TypeError:('unable to convert object to vim dictionary',)
  <<< Finished
  >>> Testing ConvertFromPyObject using fd(self=%s)
! fd(self=None):TypeError:('unable to convert object to vim dictionary',)
! fd(self={"": 1}):ValueError:('empty keys are not allowed',)
! fd(self={u"": 1}):ValueError:('empty keys are not allowed',)
! fd(self=FailingMapping()):NotImplementedError:()
! fd(self=FailingMappingKey()):NotImplementedError:()
  <<< Finished
  >>> Testing ConvertFromPyMapping using fd(self=%s)
! fd(self=[]):TypeError:('unable to convert object to vim dictionary',)
  <<< Finished
  > TabPage
  >> TabPageAttr
! vim.current.tabpage.xxx:AttributeError:('xxx',)
  > TabList
  >> TabListItem
! vim.tabpages[1000]:IndexError:('no such tab page',)
  > Window
  >> WindowAttr
! vim.current.window.xxx:AttributeError:('xxx',)
  >> WindowSetattr
! vim.current.window.buffer = 0:TypeError:('readonly attribute',)
! vim.current.window.cursor = (100000000, 100000000):error:('cursor position outside buffer',)
! vim.current.window.cursor = True:TypeError:('argument must be 2-item sequence, not bool',)
! vim.current.window.height = "abc":TypeError:('an integer is required',)
! vim.current.window.width  = "abc":TypeError:('an integer is required',)
! vim.current.window.xxxxxx = True:AttributeError:('xxxxxx',)
  > WinList
  >> WinListItem
! vim.windows[1000]:IndexError:('no such window',)
  > Buffer
  >> StringToLine (indirect)
! vim.current.buffer[0] = "\na":error:('string cannot contain newlines',)
  >> SetBufferLine (indirect)
! vim.current.buffer[0] = True:TypeError:('bad argument type for built-in operation',)
  >> SetBufferLines (indirect)
! vim.current.buffer[:] = True:TypeError:('bad argument type for built-in operation',)
! vim.current.buffer[:] = ["\na", "bc"]:error:('string cannot contain newlines',)
  >> InsertBufferLines (indirect)
! vim.current.buffer.append(None):TypeError:('bad argument type for built-in operation',)
! vim.current.buffer.append(["\na", "bc"]):error:('string cannot contain newlines',)
! vim.current.buffer.append("\nbc"):error:('string cannot contain newlines',)
  >> RBItem
! vim.current.buffer[100000000]:IndexError:('line number out of range',)
  >> RBAsItem
! vim.current.buffer[100000000] = "":IndexError:('line number out of range',)
  >> BufferAttr
! vim.current.buffer.xxx:AttributeError:('xxx',)
  >> BufferSetattr
! vim.current.buffer.name = True:TypeError:('object must be string',)
! vim.current.buffer.xxx = True:AttributeError:('xxx',)
  >> BufferMark
! vim.current.buffer.mark(0):TypeError:('must be string, not int',)
! vim.current.buffer.mark("abc"):ValueError:('mark name must be a single character',)
! vim.current.buffer.mark("!"):error:('invalid mark name',)
  >> BufferRange
! vim.current.buffer.range(1, 2, 3):TypeError:('function takes exactly 2 arguments (3 given)',)
  > BufMap
  >> BufMapItem
! vim.buffers[None]:TypeError:('key must be integer',)
! vim.buffers[100000000]:KeyError:(100000000,)
  > Current
  >> CurrentGetattr
! vim.current.xxx:AttributeError:('xxx',)
  >> CurrentSetattr
! vim.current.line = True:TypeError:('bad argument type for built-in operation',)
! vim.current.buffer = True:TypeError:('expected vim.Buffer object',)
! vim.current.window = True:TypeError:('expected vim.Window object',)
! vim.current.tabpage = True:TypeError:('expected vim.TabPage object',)
! vim.current.xxx = True:AttributeError:('xxx',)
  2,xx
  before
  after
! vim.command("throw 'abc'"):error:('abc',)
! Exe("throw 'def'"):error:('def',)
! vim.eval("Exe('throw ''ghi''')"):error:('ghi',)
! vim.eval("Exe('echoerr ''jkl''')"):error:('Vim(echoerr):jkl',)
! vim.eval("Exe('xxx_non_existent_command_xxx')"):error:('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',)
! vim.bindeval("Exe('xxx_non_existent_command_xxx')"):error:('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',)
*** ../vim-7.3.1172/src/version.c	2013-06-12 14:20:15.000000000 +0200
--- src/version.c	2013-06-12 14:22:25.000000000 +0200
***************
*** 730,731 ****
--- 730,733 ----
  {   /* Add new patch number below this line */
+ /**/
+     1173,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
168. You have your own domain name.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
