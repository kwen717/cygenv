To: vim_dev@googlegroups.com
Subject: Patch 7.3.992
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.3.992
Problem:    Python: Too many type casts.
Solution:   Change argument types. (ZyX)
Files:	    src/if_py_both.h, src/if_python3.c, src/if_python.c


*** ../vim-7.3.991/src/if_py_both.h	2013-05-21 18:19:33.000000000 +0200
--- src/if_py_both.h	2013-05-21 18:22:03.000000000 +0200
***************
*** 76,82 ****
  } OutputObject;
  
      static int
! OutputSetattr(PyObject *self, char *name, PyObject *val)
  {
      if (val == NULL)
      {
--- 76,82 ----
  } OutputObject;
  
      static int
! OutputSetattr(OutputObject *self, char *name, PyObject *val)
  {
      if (val == NULL)
      {
***************
*** 93,99 ****
  	    return -1;
  	}
  
! 	((OutputObject *)(self))->softspace = PyInt_AsLong(val);
  	return 0;
      }
  
--- 93,99 ----
  	    return -1;
  	}
  
! 	self->softspace = PyInt_AsLong(val);
  	return 0;
      }
  
***************
*** 152,162 ****
  }
  
      static PyObject *
! OutputWrite(PyObject *self, PyObject *args)
  {
      Py_ssize_t len = 0;
      char *str = NULL;
!     int error = ((OutputObject *)(self))->error;
  
      if (!PyArg_ParseTuple(args, "et#", ENC_OPT, &str, &len))
  	return NULL;
--- 152,162 ----
  }
  
      static PyObject *
! OutputWrite(OutputObject *self, PyObject *args)
  {
      Py_ssize_t len = 0;
      char *str = NULL;
!     int error = self->error;
  
      if (!PyArg_ParseTuple(args, "et#", ENC_OPT, &str, &len))
  	return NULL;
***************
*** 173,184 ****
  }
  
      static PyObject *
! OutputWritelines(PyObject *self, PyObject *args)
  {
      PyInt n;
      PyInt i;
      PyObject *list;
!     int error = ((OutputObject *)(self))->error;
  
      if (!PyArg_ParseTuple(args, "O", &list))
  	return NULL;
--- 173,184 ----
  }
  
      static PyObject *
! OutputWritelines(OutputObject *self, PyObject *args)
  {
      PyInt n;
      PyInt i;
      PyObject *list;
!     int error = self->error;
  
      if (!PyArg_ParseTuple(args, "O", &list))
  	return NULL;
***************
*** 220,226 ****
  }
  
      static PyObject *
! OutputFlush(PyObject *self UNUSED, PyObject *args UNUSED)
  {
      /* do nothing */
      Py_INCREF(Py_None);
--- 220,226 ----
  }
  
      static PyObject *
! OutputFlush(PyObject *self UNUSED)
  {
      /* do nothing */
      Py_INCREF(Py_None);
***************
*** 230,240 ****
  /***************/
  
  static struct PyMethodDef OutputMethods[] = {
!     /* name,	    function,		calling,    documentation */
!     {"write",	    OutputWrite,	1,	    ""},
!     {"writelines",  OutputWritelines,	1,	    ""},
!     {"flush",	    OutputFlush,	1,	    ""},
!     { NULL,	    NULL,		0,	    NULL}
  };
  
  static OutputObject Output =
--- 230,240 ----
  /***************/
  
  static struct PyMethodDef OutputMethods[] = {
!     /* name,	    function,				calling,	doc */
!     {"write",	    (PyCFunction)OutputWrite,		METH_VARARGS,	""},
!     {"writelines",  (PyCFunction)OutputWritelines,	METH_VARARGS,	""},
!     {"flush",	    (PyCFunction)OutputFlush,		METH_NOARGS,	""},
!     { NULL,	    NULL,				0,		NULL}
  };
  
  static OutputObject Output =
***************
*** 533,544 ****
   */
  
  static struct PyMethodDef VimMethods[] = {
!     /* name,	     function,		calling,    documentation */
!     {"command",	     VimCommand,	1,	    "Execute a Vim ex-mode command" },
!     {"eval",	     VimEval,		1,	    "Evaluate an expression using Vim evaluator" },
!     {"bindeval",     VimEvalPy,		1,	    "Like eval(), but returns objects attached to vim ones"},
!     {"strwidth",     VimStrwidth,	1,	    "Screen string width, counts <Tab> as having width 1"},
!     { NULL,	     NULL,		0,	    NULL }
  };
  
  /*
--- 533,544 ----
   */
  
  static struct PyMethodDef VimMethods[] = {
!     /* name,	     function,		calling,	documentation */
!     {"command",	     VimCommand,	METH_VARARGS,	"Execute a Vim ex-mode command" },
!     {"eval",	     VimEval,		METH_VARARGS,	"Evaluate an expression using Vim evaluator" },
!     {"bindeval",     VimEvalPy,		METH_VARARGS,	"Like eval(), but returns objects attached to vim ones"},
!     {"strwidth",     VimStrwidth,	METH_VARARGS,	"Screen string width, counts <Tab> as having width 1"},
!     { NULL,	     NULL,		0,		NULL }
  };
  
  /*
***************
*** 583,604 ****
  }
  
      static void
! IterDestructor(PyObject *self)
  {
!     IterObject *this = (IterObject *)(self);
! 
!     this->destruct(this->cur);
  
      DESTRUCTOR_FINISH(self);
  }
  
      static int
! IterTraverse(PyObject *self, visitproc visit, void *arg)
  {
!     IterObject *this = (IterObject *)(self);
! 
!     if (this->traverse != NULL)
! 	return this->traverse(this->cur, visit, arg);
      else
  	return 0;
  }
--- 583,600 ----
  }
  
      static void
! IterDestructor(IterObject *self)
  {
!     self->destruct(self->cur);
  
      DESTRUCTOR_FINISH(self);
  }
  
      static int
! IterTraverse(IterObject *self, visitproc visit, void *arg)
  {
!     if (self->traverse != NULL)
! 	return self->traverse(self->cur, visit, arg);
      else
  	return 0;
  }
***************
*** 609,630 ****
  #endif
  
      static int
! IterClear(PyObject *self)
  {
!     IterObject *this = (IterObject *)(self);
! 
!     if (this->clear != NULL)
! 	return this->clear(&this->cur);
      else
  	return 0;
  }
  
      static PyObject *
! IterNext(PyObject *self)
  {
!     IterObject *this = (IterObject *)(self);
! 
!     return this->next(&this->cur);
  }
  
      static PyObject *
--- 605,622 ----
  #endif
  
      static int
! IterClear(IterObject *self)
  {
!     if (self->clear != NULL)
! 	return self->clear(&self->cur);
      else
  	return 0;
  }
  
      static PyObject *
! IterNext(IterObject *self)
  {
!     return self->next(&self->cur);
  }
  
      static PyObject *
***************
*** 711,731 ****
  }
  
      static void
! DictionaryDestructor(PyObject *self)
  {
!     DictionaryObject	*this = ((DictionaryObject *) (self));
! 
!     pyll_remove(&this->ref, &lastdict);
!     dict_unref(this->dict);
  
      DESTRUCTOR_FINISH(self);
  }
  
      static int
! DictionarySetattr(PyObject *self, char *name, PyObject *val)
  {
-     DictionaryObject *this = (DictionaryObject *)(self);
- 
      if (val == NULL)
      {
  	PyErr_SetString(PyExc_AttributeError, _("Cannot delete DictionaryObject attributes"));
--- 703,719 ----
  }
  
      static void
! DictionaryDestructor(DictionaryObject *self)
  {
!     pyll_remove(&self->ref, &lastdict);
!     dict_unref(self->dict);
  
      DESTRUCTOR_FINISH(self);
  }
  
      static int
! DictionarySetattr(DictionaryObject *self, char *name, PyObject *val)
  {
      if (val == NULL)
      {
  	PyErr_SetString(PyExc_AttributeError, _("Cannot delete DictionaryObject attributes"));
***************
*** 734,740 ****
  
      if (strcmp(name, "locked") == 0)
      {
! 	if (this->dict->dv_lock == VAR_FIXED)
  	{
  	    PyErr_SetString(PyExc_TypeError, _("Cannot modify fixed dictionary"));
  	    return -1;
--- 722,728 ----
  
      if (strcmp(name, "locked") == 0)
      {
! 	if (self->dict->dv_lock == VAR_FIXED)
  	{
  	    PyErr_SetString(PyExc_TypeError, _("Cannot modify fixed dictionary"));
  	    return -1;
***************
*** 745,753 ****
  	    if (istrue == -1)
  		return -1;
  	    else if (istrue)
! 		this->dict->dv_lock = VAR_LOCKED;
  	    else
! 		this->dict->dv_lock = 0;
  	}
  	return 0;
      }
--- 733,741 ----
  	    if (istrue == -1)
  		return -1;
  	    else if (istrue)
! 		self->dict->dv_lock = VAR_LOCKED;
  	    else
! 		self->dict->dv_lock = 0;
  	}
  	return 0;
      }
***************
*** 759,771 ****
  }
  
      static PyInt
! DictionaryLength(PyObject *self)
  {
!     return ((PyInt) ((((DictionaryObject *)(self))->dict->dv_hashtab.ht_used)));
  }
  
      static PyObject *
! DictionaryItem(PyObject *self, PyObject *keyObject)
  {
      char_u	*key;
      dictitem_T	*di;
--- 747,759 ----
  }
  
      static PyInt
! DictionaryLength(DictionaryObject *self)
  {
!     return ((PyInt) (self->dict->dv_hashtab.ht_used));
  }
  
      static PyObject *
! DictionaryItem(DictionaryObject *self, PyObject *keyObject)
  {
      char_u	*key;
      dictitem_T	*di;
***************
*** 773,779 ****
  
      DICTKEY_GET_NOTEMPTY(NULL)
  
!     di = dict_find(((DictionaryObject *) (self))->dict, key, -1);
  
      DICTKEY_UNREF
  
--- 761,767 ----
  
      DICTKEY_GET_NOTEMPTY(NULL)
  
!     di = dict_find(self->dict, key, -1);
  
      DICTKEY_UNREF
  
***************
*** 787,797 ****
  }
  
      static PyInt
! DictionaryAssItem(PyObject *self, PyObject *keyObject, PyObject *valObject)
  {
      char_u	*key;
      typval_T	tv;
!     dict_T	*d = ((DictionaryObject *)(self))->dict;
      dictitem_T	*di;
      DICTKEY_DECL
  
--- 775,785 ----
  }
  
      static PyInt
! DictionaryAssItem(DictionaryObject *self, PyObject *keyObject, PyObject *valObject)
  {
      char_u	*key;
      typval_T	tv;
!     dict_T	*d = self->dict;
      dictitem_T	*di;
      DICTKEY_DECL
  
***************
*** 852,860 ****
  }
  
      static PyObject *
! DictionaryListKeys(PyObject *self UNUSED)
  {
!     dict_T	*dict = ((DictionaryObject *)(self))->dict;
      long_u	todo = dict->dv_hashtab.ht_used;
      Py_ssize_t	i = 0;
      PyObject	*r;
--- 840,848 ----
  }
  
      static PyObject *
! DictionaryListKeys(DictionaryObject *self)
  {
!     dict_T	*dict = self->dict;
      long_u	todo = dict->dv_hashtab.ht_used;
      Py_ssize_t	i = 0;
      PyObject	*r;
***************
*** 880,887 ****
  };
  
  static struct PyMethodDef DictionaryMethods[] = {
!     {"keys", (PyCFunction)DictionaryListKeys, METH_NOARGS, ""},
!     { NULL,	    NULL,		0,	    NULL }
  };
  
  static PyTypeObject ListType;
--- 868,875 ----
  };
  
  static struct PyMethodDef DictionaryMethods[] = {
!     {"keys",	(PyCFunction)DictionaryListKeys,	METH_NOARGS,	""},
!     { NULL,	NULL,					0,		NULL }
  };
  
  static PyTypeObject ListType;
***************
*** 912,923 ****
  }
  
      static void
! ListDestructor(PyObject *self)
  {
!     ListObject *this = (ListObject *)(self);
! 
!     pyll_remove(&this->ref, &lastlist);
!     list_unref(this->list);
  
      DESTRUCTOR_FINISH(self);
  }
--- 900,909 ----
  }
  
      static void
! ListDestructor(ListObject *self)
  {
!     pyll_remove(&self->ref, &lastlist);
!     list_unref(self->list);
  
      DESTRUCTOR_FINISH(self);
  }
***************
*** 952,973 ****
  }
  
      static PyInt
! ListLength(PyObject *self)
  {
!     return ((PyInt) (((ListObject *) (self))->list->lv_len));
  }
  
      static PyObject *
! ListItem(PyObject *self, Py_ssize_t index)
  {
      listitem_T	*li;
  
!     if (index>=ListLength(self))
      {
  	PyErr_SetString(PyExc_IndexError, _("list index out of range"));
  	return NULL;
      }
!     li = list_find(((ListObject *) (self))->list, (long) index);
      if (li == NULL)
      {
  	PyErr_SetVim(_("internal error: failed to get vim list item"));
--- 938,959 ----
  }
  
      static PyInt
! ListLength(ListObject *self)
  {
!     return ((PyInt) (self->list->lv_len));
  }
  
      static PyObject *
! ListItem(ListObject *self, Py_ssize_t index)
  {
      listitem_T	*li;
  
!     if (index >= ListLength(self))
      {
  	PyErr_SetString(PyExc_IndexError, _("list index out of range"));
  	return NULL;
      }
!     li = list_find(self->list, (long) index);
      if (li == NULL)
      {
  	PyErr_SetVim(_("internal error: failed to get vim list item"));
***************
*** 991,997 ****
  	last = size;
  
      static PyObject *
! ListSlice(PyObject *self, Py_ssize_t first, Py_ssize_t last)
  {
      PyInt	i;
      PyInt	size = ListLength(self);
--- 977,983 ----
  	last = size;
  
      static PyObject *
! ListSlice(ListObject *self, Py_ssize_t first, Py_ssize_t last)
  {
      PyInt	i;
      PyInt	size = ListLength(self);
***************
*** 1058,1067 ****
  }
  
      static PyObject *
! ListIter(PyObject *self)
  {
      listiterinfo_T	*lii;
!     list_T	*l = ((ListObject *) (self))->list;
  
      if (!(lii = PyMem_New(listiterinfo_T, 1)))
      {
--- 1044,1053 ----
  }
  
      static PyObject *
! ListIter(ListObject *self)
  {
      listiterinfo_T	*lii;
!     list_T	*l = self->list;
  
      if (!(lii = PyMem_New(listiterinfo_T, 1)))
      {
***************
*** 1079,1088 ****
  }
  
      static int
! ListAssItem(PyObject *self, Py_ssize_t index, PyObject *obj)
  {
      typval_T	tv;
!     list_T	*l = ((ListObject *) (self))->list;
      listitem_T	*li;
      Py_ssize_t	length = ListLength(self);
  
--- 1065,1074 ----
  }
  
      static int
! ListAssItem(ListObject *self, Py_ssize_t index, PyObject *obj)
  {
      typval_T	tv;
!     list_T	*l = self->list;
      listitem_T	*li;
      Py_ssize_t	length = ListLength(self);
  
***************
*** 1127,1133 ****
  }
  
      static int
! ListAssSlice(PyObject *self, Py_ssize_t first, Py_ssize_t last, PyObject *obj)
  {
      PyInt	size = ListLength(self);
      Py_ssize_t	i;
--- 1113,1119 ----
  }
  
      static int
! ListAssSlice(ListObject *self, Py_ssize_t first, Py_ssize_t last, PyObject *obj)
  {
      PyInt	size = ListLength(self);
      Py_ssize_t	i;
***************
*** 1136,1142 ****
      listitem_T	*li;
      listitem_T	*next;
      typval_T	v;
!     list_T	*l = ((ListObject *) (self))->list;
  
      if (l->lv_lock)
      {
--- 1122,1128 ----
      listitem_T	*li;
      listitem_T	*next;
      typval_T	v;
!     list_T	*l = self->list;
  
      if (l->lv_lock)
      {
***************
*** 1196,1204 ****
  }
  
      static PyObject *
! ListConcatInPlace(PyObject *self, PyObject *obj)
  {
!     list_T	*l = ((ListObject *) (self))->list;
      PyObject	*lookup_dict;
  
      if (l->lv_lock)
--- 1182,1190 ----
  }
  
      static PyObject *
! ListConcatInPlace(ListObject *self, PyObject *obj)
  {
!     list_T	*l = self->list;
      PyObject	*lookup_dict;
  
      if (l->lv_lock)
***************
*** 1222,1235 ****
      Py_DECREF(lookup_dict);
  
      Py_INCREF(self);
!     return self;
  }
  
      static int
! ListSetattr(PyObject *self, char *name, PyObject *val)
  {
-     ListObject *this = (ListObject *)(self);
- 
      if (val == NULL)
      {
  	PyErr_SetString(PyExc_AttributeError,
--- 1208,1219 ----
      Py_DECREF(lookup_dict);
  
      Py_INCREF(self);
!     return (PyObject *)(self);
  }
  
      static int
! ListSetattr(ListObject *self, char *name, PyObject *val)
  {
      if (val == NULL)
      {
  	PyErr_SetString(PyExc_AttributeError,
***************
*** 1239,1245 ****
  
      if (strcmp(name, "locked") == 0)
      {
! 	if (this->list->lv_lock == VAR_FIXED)
  	{
  	    PyErr_SetString(PyExc_TypeError, _("cannot modify fixed list"));
  	    return -1;
--- 1223,1229 ----
  
      if (strcmp(name, "locked") == 0)
      {
! 	if (self->list->lv_lock == VAR_FIXED)
  	{
  	    PyErr_SetString(PyExc_TypeError, _("cannot modify fixed list"));
  	    return -1;
***************
*** 1250,1258 ****
  	    if (istrue == -1)
  		return -1;
  	    else if (istrue)
! 		this->list->lv_lock = VAR_LOCKED;
  	    else
! 		this->list->lv_lock = 0;
  	}
  	return 0;
      }
--- 1234,1242 ----
  	    if (istrue == -1)
  		return -1;
  	    else if (istrue)
! 		self->list->lv_lock = VAR_LOCKED;
  	    else
! 		self->list->lv_lock = 0;
  	}
  	return 0;
      }
***************
*** 1264,1271 ****
  }
  
  static struct PyMethodDef ListMethods[] = {
!     {"extend", (PyCFunction)ListConcatInPlace, METH_O, ""},
!     { NULL,	    NULL,		0,	    NULL }
  };
  
  typedef struct
--- 1248,1255 ----
  }
  
  static struct PyMethodDef ListMethods[] = {
!     {"extend",	(PyCFunction)ListConcatInPlace,	METH_O,	""},
!     { NULL,	NULL,				0,	NULL }
  };
  
  typedef struct
***************
*** 1296,1316 ****
  }
  
      static void
! FunctionDestructor(PyObject *self)
  {
!     FunctionObject	*this = (FunctionObject *) (self);
! 
!     func_unref(this->name);
!     PyMem_Free(this->name);
  
      DESTRUCTOR_FINISH(self);
  }
  
      static PyObject *
! FunctionCall(PyObject *self, PyObject *argsObject, PyObject *kwargs)
  {
!     FunctionObject	*this = (FunctionObject *)(self);
!     char_u	*name = this->name;
      typval_T	args;
      typval_T	selfdicttv;
      typval_T	rettv;
--- 1280,1297 ----
  }
  
      static void
! FunctionDestructor(FunctionObject *self)
  {
!     func_unref(self->name);
!     PyMem_Free(self->name);
  
      DESTRUCTOR_FINISH(self);
  }
  
      static PyObject *
! FunctionCall(FunctionObject *self, PyObject *argsObject, PyObject *kwargs)
  {
!     char_u	*name = self->name;
      typval_T	args;
      typval_T	selfdicttv;
      typval_T	rettv;
***************
*** 1368,1375 ****
  }
  
  static struct PyMethodDef FunctionMethods[] = {
!     {"__call__",    (PyCFunction)FunctionCall, METH_VARARGS|METH_KEYWORDS, ""},
!     { NULL,	    NULL,		0,	    NULL }
  };
  
  /*
--- 1349,1356 ----
  }
  
  static struct PyMethodDef FunctionMethods[] = {
!     {"__call__",    (PyCFunction)FunctionCall,	METH_VARARGS|METH_KEYWORDS, ""},
!     { NULL,	    NULL,			0,			   NULL}
  };
  
  /*
***************
*** 1415,1443 ****
  }
  
      static void
! OptionsDestructor(PyObject *self)
  {
!     if (((OptionsObject *)(self))->fromObj)
! 	Py_DECREF(((OptionsObject *)(self))->fromObj);
      DESTRUCTOR_FINISH(self);
  }
  
      static int
! OptionsTraverse(PyObject *self, visitproc visit, void *arg)
  {
!     Py_VISIT(((OptionsObject *)(self))->fromObj);
      return 0;
  }
  
      static int
! OptionsClear(PyObject *self)
  {
!     Py_CLEAR(((OptionsObject *)(self))->fromObj);
      return 0;
  }
  
      static PyObject *
! OptionsItem(OptionsObject *this, PyObject *keyObject)
  {
      char_u	*key;
      int		flags;
--- 1396,1424 ----
  }
  
      static void
! OptionsDestructor(OptionsObject *self)
  {
!     if (self->fromObj)
! 	Py_DECREF(self->fromObj);
      DESTRUCTOR_FINISH(self);
  }
  
      static int
! OptionsTraverse(OptionsObject *self, visitproc visit, void *arg)
  {
!     Py_VISIT(self->fromObj);
      return 0;
  }
  
      static int
! OptionsClear(OptionsObject *self)
  {
!     Py_CLEAR(self->fromObj);
      return 0;
  }
  
      static PyObject *
! OptionsItem(OptionsObject *self, PyObject *keyObject)
  {
      char_u	*key;
      int		flags;
***************
*** 1445,1457 ****
      char_u	*stringval;
      DICTKEY_DECL
  
!     if (this->Check(this->from))
  	return NULL;
  
      DICTKEY_GET_NOTEMPTY(NULL)
  
      flags = get_option_value_strict(key, &numval, &stringval,
! 				    this->opt_type, this->from);
  
      DICTKEY_UNREF
  
--- 1426,1438 ----
      char_u	*stringval;
      DICTKEY_DECL
  
!     if (self->Check(self->from))
  	return NULL;
  
      DICTKEY_GET_NOTEMPTY(NULL)
  
      flags = get_option_value_strict(key, &numval, &stringval,
! 				    self->opt_type, self->from);
  
      DICTKEY_UNREF
  
***************
*** 1532,1538 ****
  }
  
      static int
! OptionsAssItem(OptionsObject *this, PyObject *keyObject, PyObject *valObject)
  {
      char_u	*key;
      int		flags;
--- 1513,1519 ----
  }
  
      static int
! OptionsAssItem(OptionsObject *self, PyObject *keyObject, PyObject *valObject)
  {
      char_u	*key;
      int		flags;
***************
*** 1540,1552 ****
      int		r = 0;
      DICTKEY_DECL
  
!     if (this->Check(this->from))
  	return -1;
  
      DICTKEY_GET_NOTEMPTY(-1)
  
      flags = get_option_value_strict(key, NULL, NULL,
! 				    this->opt_type, this->from);
  
      DICTKEY_UNREF
  
--- 1521,1533 ----
      int		r = 0;
      DICTKEY_DECL
  
!     if (self->Check(self->from))
  	return -1;
  
      DICTKEY_GET_NOTEMPTY(-1)
  
      flags = get_option_value_strict(key, NULL, NULL,
! 				    self->opt_type, self->from);
  
      DICTKEY_UNREF
  
***************
*** 1558,1564 ****
  
      if (valObject == NULL)
      {
! 	if (this->opt_type == SREQ_GLOBAL)
  	{
  	    PyErr_SetString(PyExc_ValueError,
  		    _("unable to unset global option"));
--- 1539,1545 ----
  
      if (valObject == NULL)
      {
! 	if (self->opt_type == SREQ_GLOBAL)
  	{
  	    PyErr_SetString(PyExc_ValueError,
  		    _("unable to unset global option"));
***************
*** 1572,1583 ****
  	}
  	else
  	{
! 	    unset_global_local_option(key, this->from);
  	    return 0;
  	}
      }
  
!     opt_flags = (this->opt_type ? OPT_LOCAL : OPT_GLOBAL);
  
      if (flags & SOPT_BOOL)
      {
--- 1553,1564 ----
  	}
  	else
  	{
! 	    unset_global_local_option(key, self->from);
  	    return 0;
  	}
      }
  
!     opt_flags = (self->opt_type ? OPT_LOCAL : OPT_GLOBAL);
  
      if (flags & SOPT_BOOL)
      {
***************
*** 1585,1591 ****
  	if (istrue == -1)
  	    return -1;
  	r = set_option_value_for(key, istrue, NULL,
! 				opt_flags, this->opt_type, this->from);
      }
      else if (flags & SOPT_NUM)
      {
--- 1566,1572 ----
  	if (istrue == -1)
  	    return -1;
  	r = set_option_value_for(key, istrue, NULL,
! 				opt_flags, self->opt_type, self->from);
      }
      else if (flags & SOPT_NUM)
      {
***************
*** 1605,1611 ****
  	}
  
  	r = set_option_value_for(key, val, NULL, opt_flags,
! 				this->opt_type, this->from);
      }
      else
      {
--- 1586,1592 ----
  	}
  
  	r = set_option_value_for(key, val, NULL, opt_flags,
! 				self->opt_type, self->from);
      }
      else
      {
***************
*** 1643,1649 ****
  	}
  
  	r = set_option_value_for(key, 0, val, opt_flags,
! 				this->opt_type, this->from);
  	vim_free(val);
      }
  
--- 1624,1630 ----
  	}
  
  	r = set_option_value_for(key, 0, val, opt_flags,
! 				self->opt_type, self->from);
  	vim_free(val);
      }
  
***************
*** 1670,1678 ****
  static PyTypeObject TabPageType;
  
      static int
! CheckTabPage(TabPageObject *this)
  {
!     if (this->tab == INVALID_TABPAGE_VALUE)
      {
  	PyErr_SetVim(_("attempt to refer to deleted tab page"));
  	return -1;
--- 1651,1659 ----
  static PyTypeObject TabPageType;
  
      static int
! CheckTabPage(TabPageObject *self)
  {
!     if (self->tab == INVALID_TABPAGE_VALUE)
      {
  	PyErr_SetVim(_("attempt to refer to deleted tab page"));
  	return -1;
***************
*** 1704,1754 ****
  }
  
      static void
! TabPageDestructor(PyObject *self)
  {
!     TabPageObject *this = (TabPageObject *)(self);
! 
!     if (this->tab && this->tab != INVALID_TABPAGE_VALUE)
! 	TAB_PYTHON_REF(this->tab) = NULL;
  
      DESTRUCTOR_FINISH(self);
  }
  
      static PyObject *
! TabPageAttr(TabPageObject *this, char *name)
  {
      if (strcmp(name, "windows") == 0)
! 	return WinListNew(this);
      else if (strcmp(name, "number") == 0)
! 	return PyLong_FromLong((long) get_tab_number(this->tab));
      else if (strcmp(name, "vars") == 0)
! 	return DictionaryNew(this->tab->tp_vars);
      else if (strcmp(name, "window") == 0)
      {
  	/* For current tab window.c does not bother to set or update tp_curwin
  	 */
! 	if (this->tab == curtab)
  	    return WindowNew(curwin, curtab);
  	else
! 	    return WindowNew(this->tab->tp_curwin, this->tab);
      }
      return NULL;
  }
  
      static PyObject *
! TabPageRepr(PyObject *self)
  {
      static char repr[100];
-     TabPageObject *this = (TabPageObject *)(self);
  
!     if (this->tab == INVALID_TABPAGE_VALUE)
      {
  	vim_snprintf(repr, 100, _("<tabpage object (deleted) at %p>"), (self));
  	return PyString_FromString(repr);
      }
      else
      {
! 	int	t = get_tab_number(this->tab);
  
  	if (t == 0)
  	    vim_snprintf(repr, 100, _("<tabpage object (unknown) at %p>"),
--- 1685,1732 ----
  }
  
      static void
! TabPageDestructor(TabPageObject *self)
  {
!     if (self->tab && self->tab != INVALID_TABPAGE_VALUE)
! 	TAB_PYTHON_REF(self->tab) = NULL;
  
      DESTRUCTOR_FINISH(self);
  }
  
      static PyObject *
! TabPageAttr(TabPageObject *self, char *name)
  {
      if (strcmp(name, "windows") == 0)
! 	return WinListNew(self);
      else if (strcmp(name, "number") == 0)
! 	return PyLong_FromLong((long) get_tab_number(self->tab));
      else if (strcmp(name, "vars") == 0)
! 	return DictionaryNew(self->tab->tp_vars);
      else if (strcmp(name, "window") == 0)
      {
  	/* For current tab window.c does not bother to set or update tp_curwin
  	 */
! 	if (self->tab == curtab)
  	    return WindowNew(curwin, curtab);
  	else
! 	    return WindowNew(self->tab->tp_curwin, self->tab);
      }
      return NULL;
  }
  
      static PyObject *
! TabPageRepr(TabPageObject *self)
  {
      static char repr[100];
  
!     if (self->tab == INVALID_TABPAGE_VALUE)
      {
  	vim_snprintf(repr, 100, _("<tabpage object (deleted) at %p>"), (self));
  	return PyString_FromString(repr);
      }
      else
      {
! 	int	t = get_tab_number(self->tab);
  
  	if (t == 0)
  	    vim_snprintf(repr, 100, _("<tabpage object (unknown) at %p>"),
***************
*** 1818,1826 ****
  static PyTypeObject WindowType;
  
      static int
! CheckWindow(WindowObject *this)
  {
!     if (this->win == INVALID_WINDOW_VALUE)
      {
  	PyErr_SetVim(_("attempt to refer to deleted window"));
  	return -1;
--- 1796,1804 ----
  static PyTypeObject WindowType;
  
      static int
! CheckWindow(WindowObject *self)
  {
!     if (self->win == INVALID_WINDOW_VALUE)
      {
  	PyErr_SetVim(_("attempt to refer to deleted window"));
  	return -1;
***************
*** 1869,1882 ****
  }
  
      static void
! WindowDestructor(PyObject *self)
  {
!     WindowObject *this = (WindowObject *)(self);
! 
!     if (this->win && this->win != INVALID_WINDOW_VALUE)
! 	WIN_PYTHON_REF(this->win) = NULL;
  
!     Py_DECREF(((PyObject *)(this->tabObject)));
  
      DESTRUCTOR_FINISH(self);
  }
--- 1847,1858 ----
  }
  
      static void
! WindowDestructor(WindowObject *self)
  {
!     if (self->win && self->win != INVALID_WINDOW_VALUE)
! 	WIN_PYTHON_REF(self->win) = NULL;
  
!     Py_DECREF(((PyObject *)(self->tabObject)));
  
      DESTRUCTOR_FINISH(self);
  }
***************
*** 1899,1956 ****
  	return firstwin;
  }
      static int
! WindowTraverse(PyObject *self, visitproc visit, void *arg)
  {
!     Py_VISIT(((PyObject *)(((WindowObject *)(self))->tabObject)));
      return 0;
  }
  
      static int
! WindowClear(PyObject *self)
  {
!     Py_CLEAR((((WindowObject *)(self))->tabObject));
      return 0;
  }
  
      static PyObject *
! WindowAttr(WindowObject *this, char *name)
  {
      if (strcmp(name, "buffer") == 0)
! 	return (PyObject *)BufferNew(this->win->w_buffer);
      else if (strcmp(name, "cursor") == 0)
      {
! 	pos_T *pos = &this->win->w_cursor;
  
  	return Py_BuildValue("(ll)", (long)(pos->lnum), (long)(pos->col));
      }
      else if (strcmp(name, "height") == 0)
! 	return PyLong_FromLong((long)(this->win->w_height));
  #ifdef FEAT_WINDOWS
      else if (strcmp(name, "row") == 0)
! 	return PyLong_FromLong((long)(this->win->w_winrow));
  #endif
  #ifdef FEAT_VERTSPLIT
      else if (strcmp(name, "width") == 0)
! 	return PyLong_FromLong((long)(W_WIDTH(this->win)));
      else if (strcmp(name, "col") == 0)
! 	return PyLong_FromLong((long)(W_WINCOL(this->win)));
  #endif
      else if (strcmp(name, "vars") == 0)
! 	return DictionaryNew(this->win->w_vars);
      else if (strcmp(name, "options") == 0)
! 	return OptionsNew(SREQ_WIN, this->win, (checkfun) CheckWindow,
! 			(PyObject *) this);
      else if (strcmp(name, "number") == 0)
      {
! 	if (CheckTabPage(this->tabObject))
  	    return NULL;
  	return PyLong_FromLong((long)
! 		get_win_number(this->win, get_firstwin(this->tabObject)));
      }
      else if (strcmp(name, "tabpage") == 0)
      {
! 	Py_INCREF(this->tabObject);
! 	return (PyObject *)(this->tabObject);
      }
      else if (strcmp(name,"__members__") == 0)
  	return Py_BuildValue("[sssssssss]", "buffer", "cursor", "height",
--- 1875,1932 ----
  	return firstwin;
  }
      static int
! WindowTraverse(WindowObject *self, visitproc visit, void *arg)
  {
!     Py_VISIT(((PyObject *)(self->tabObject)));
      return 0;
  }
  
      static int
! WindowClear(WindowObject *self)
  {
!     Py_CLEAR(self->tabObject);
      return 0;
  }
  
      static PyObject *
! WindowAttr(WindowObject *self, char *name)
  {
      if (strcmp(name, "buffer") == 0)
! 	return (PyObject *)BufferNew(self->win->w_buffer);
      else if (strcmp(name, "cursor") == 0)
      {
! 	pos_T *pos = &self->win->w_cursor;
  
  	return Py_BuildValue("(ll)", (long)(pos->lnum), (long)(pos->col));
      }
      else if (strcmp(name, "height") == 0)
! 	return PyLong_FromLong((long)(self->win->w_height));
  #ifdef FEAT_WINDOWS
      else if (strcmp(name, "row") == 0)
! 	return PyLong_FromLong((long)(self->win->w_winrow));
  #endif
  #ifdef FEAT_VERTSPLIT
      else if (strcmp(name, "width") == 0)
! 	return PyLong_FromLong((long)(W_WIDTH(self->win)));
      else if (strcmp(name, "col") == 0)
! 	return PyLong_FromLong((long)(W_WINCOL(self->win)));
  #endif
      else if (strcmp(name, "vars") == 0)
! 	return DictionaryNew(self->win->w_vars);
      else if (strcmp(name, "options") == 0)
! 	return OptionsNew(SREQ_WIN, self->win, (checkfun) CheckWindow,
! 			(PyObject *) self);
      else if (strcmp(name, "number") == 0)
      {
! 	if (CheckTabPage(self->tabObject))
  	    return NULL;
  	return PyLong_FromLong((long)
! 		get_win_number(self->win, get_firstwin(self->tabObject)));
      }
      else if (strcmp(name, "tabpage") == 0)
      {
! 	Py_INCREF(self->tabObject);
! 	return (PyObject *)(self->tabObject);
      }
      else if (strcmp(name,"__members__") == 0)
  	return Py_BuildValue("[sssssssss]", "buffer", "cursor", "height",
***************
*** 1960,1970 ****
  }
  
      static int
! WindowSetattr(PyObject *self, char *name, PyObject *val)
  {
!     WindowObject *this = (WindowObject *)(self);
! 
!     if (CheckWindow(this))
  	return -1;
  
      if (strcmp(name, "buffer") == 0)
--- 1936,1944 ----
  }
  
      static int
! WindowSetattr(WindowObject *self, char *name, PyObject *val)
  {
!     if (CheckWindow(self))
  	return -1;
  
      if (strcmp(name, "buffer") == 0)
***************
*** 1980,1986 ****
  	if (!PyArg_Parse(val, "(ll)", &lnum, &col))
  	    return -1;
  
! 	if (lnum <= 0 || lnum > this->win->w_buffer->b_ml.ml_line_count)
  	{
  	    PyErr_SetVim(_("cursor position outside buffer"));
  	    return -1;
--- 1954,1960 ----
  	if (!PyArg_Parse(val, "(ll)", &lnum, &col))
  	    return -1;
  
! 	if (lnum <= 0 || lnum > self->win->w_buffer->b_ml.ml_line_count)
  	{
  	    PyErr_SetVim(_("cursor position outside buffer"));
  	    return -1;
***************
*** 1990,2002 ****
  	if (VimErrorCheck())
  	    return -1;
  
! 	this->win->w_cursor.lnum = lnum;
! 	this->win->w_cursor.col = col;
  #ifdef FEAT_VIRTUALEDIT
! 	this->win->w_cursor.coladd = 0;
  #endif
  	/* When column is out of range silently correct it. */
! 	check_cursor_col_win(this->win);
  
  	update_screen(VALID);
  	return 0;
--- 1964,1976 ----
  	if (VimErrorCheck())
  	    return -1;
  
! 	self->win->w_cursor.lnum = lnum;
! 	self->win->w_cursor.col = col;
  #ifdef FEAT_VIRTUALEDIT
! 	self->win->w_cursor.coladd = 0;
  #endif
  	/* When column is out of range silently correct it. */
! 	check_cursor_col_win(self->win);
  
  	update_screen(VALID);
  	return 0;
***************
*** 2013,2019 ****
  	need_mouse_correct = TRUE;
  #endif
  	savewin = curwin;
! 	curwin = this->win;
  	win_setheight(height);
  	curwin = savewin;
  
--- 1987,1993 ----
  	need_mouse_correct = TRUE;
  #endif
  	savewin = curwin;
! 	curwin = self->win;
  	win_setheight(height);
  	curwin = savewin;
  
***************
*** 2036,2042 ****
  	need_mouse_correct = TRUE;
  #endif
  	savewin = curwin;
! 	curwin = this->win;
  	win_setwidth(width);
  	curwin = savewin;
  
--- 2010,2016 ----
  	need_mouse_correct = TRUE;
  #endif
  	savewin = curwin;
! 	curwin = self->win;
  	win_setwidth(width);
  	curwin = savewin;
  
***************
*** 2055,2073 ****
  }
  
      static PyObject *
! WindowRepr(PyObject *self)
  {
      static char repr[100];
-     WindowObject *this = (WindowObject *)(self);
  
!     if (this->win == INVALID_WINDOW_VALUE)
      {
  	vim_snprintf(repr, 100, _("<window object (deleted) at %p>"), (self));
  	return PyString_FromString(repr);
      }
      else
      {
! 	int	w = get_win_number(this->win, firstwin);
  
  	if (w == 0)
  	    vim_snprintf(repr, 100, _("<window object (unknown) at %p>"),
--- 2029,2046 ----
  }
  
      static PyObject *
! WindowRepr(WindowObject *self)
  {
      static char repr[100];
  
!     if (self->win == INVALID_WINDOW_VALUE)
      {
  	vim_snprintf(repr, 100, _("<window object (deleted) at %p>"), (self));
  	return PyString_FromString(repr);
      }
      else
      {
! 	int	w = get_win_number(self->win, firstwin);
  
  	if (w == 0)
  	    vim_snprintf(repr, 100, _("<window object (unknown) at %p>"),
***************
*** 2110,2118 ****
  }
  
      static void
! WinListDestructor(PyObject *self)
  {
!     TabPageObject	*tabObject = ((WinListObject *)(self))->tabObject;
  
      if (tabObject)
  	Py_DECREF((PyObject *)(tabObject));
--- 2083,2091 ----
  }
  
      static void
! WinListDestructor(WinListObject *self)
  {
!     TabPageObject	*tabObject = self->tabObject;
  
      if (tabObject)
  	Py_DECREF((PyObject *)(tabObject));
***************
*** 2121,2132 ****
  }
  
      static PyInt
! WinListLength(PyObject *self)
  {
      win_T	*w;
      PyInt	n = 0;
  
!     if (!(w = get_firstwin(((WinListObject *)(self))->tabObject)))
  	return -1;
  
      while (w != NULL)
--- 2094,2105 ----
  }
  
      static PyInt
! WinListLength(WinListObject *self)
  {
      win_T	*w;
      PyInt	n = 0;
  
!     if (!(w = get_firstwin(self->tabObject)))
  	return -1;
  
      while (w != NULL)
***************
*** 2139,2155 ****
  }
  
      static PyObject *
! WinListItem(PyObject *self, PyInt n)
  {
-     WinListObject	*this = ((WinListObject *)(self));
      win_T *w;
  
!     if (!(w = get_firstwin(this->tabObject)))
  	return NULL;
  
      for (; w != NULL; w = W_NEXT(w), --n)
  	if (n == 0)
! 	    return WindowNew(w, this->tabObject? this->tabObject->tab: curtab);
  
      PyErr_SetString(PyExc_IndexError, _("no such window"));
      return NULL;
--- 2112,2127 ----
  }
  
      static PyObject *
! WinListItem(WinListObject *self, PyInt n)
  {
      win_T *w;
  
!     if (!(w = get_firstwin(self->tabObject)))
  	return NULL;
  
      for (; w != NULL; w = W_NEXT(w), --n)
  	if (n == 0)
! 	    return WindowNew(w, self->tabObject? self->tabObject->tab: curtab);
  
      PyErr_SetString(PyExc_IndexError, _("no such window"));
      return NULL;
***************
*** 2721,2729 ****
  } BufferObject;
  
      static int
! CheckBuffer(BufferObject *this)
  {
!     if (this->buf == INVALID_BUFFER_VALUE)
      {
  	PyErr_SetVim(_("attempt to refer to deleted buffer"));
  	return -1;
--- 2693,2701 ----
  } BufferObject;
  
      static int
! CheckBuffer(BufferObject *self)
  {
!     if (self->buf == INVALID_BUFFER_VALUE)
      {
  	PyErr_SetVim(_("attempt to refer to deleted buffer"));
  	return -1;
***************
*** 2922,2975 ****
  }
  
      static void
! RangeDestructor(PyObject *self)
  {
!     Py_DECREF(((RangeObject *)(self))->buf);
      DESTRUCTOR_FINISH(self);
  }
  
      static PyInt
! RangeLength(PyObject *self)
  {
      /* HOW DO WE SIGNAL AN ERROR FROM THIS FUNCTION? */
!     if (CheckBuffer(((RangeObject *)(self))->buf))
  	return -1; /* ??? */
  
!     return (((RangeObject *)(self))->end - ((RangeObject *)(self))->start + 1);
  }
  
      static PyObject *
! RangeItem(PyObject *self, PyInt n)
  {
!     return RBItem(((RangeObject *)(self))->buf, n,
! 		  ((RangeObject *)(self))->start,
! 		  ((RangeObject *)(self))->end);
  }
  
      static PyObject *
! RangeSlice(PyObject *self, PyInt lo, PyInt hi)
  {
!     return RBSlice(((RangeObject *)(self))->buf, lo, hi,
! 		   ((RangeObject *)(self))->start,
! 		   ((RangeObject *)(self))->end);
  }
  
      static PyObject *
! RangeAppend(PyObject *self, PyObject *args)
  {
!     return RBAppend(((RangeObject *)(self))->buf, args,
! 		    ((RangeObject *)(self))->start,
! 		    ((RangeObject *)(self))->end,
! 		    &((RangeObject *)(self))->end);
  }
  
      static PyObject *
! RangeRepr(PyObject *self)
  {
      static char repr[100];
-     RangeObject *this = (RangeObject *)(self);
  
!     if (this->buf->buf == INVALID_BUFFER_VALUE)
      {
  	vim_snprintf(repr, 100, "<range object (for deleted buffer) at %p>",
  								      (self));
--- 2894,2939 ----
  }
  
      static void
! RangeDestructor(RangeObject *self)
  {
!     Py_DECREF(self->buf);
      DESTRUCTOR_FINISH(self);
  }
  
      static PyInt
! RangeLength(RangeObject *self)
  {
      /* HOW DO WE SIGNAL AN ERROR FROM THIS FUNCTION? */
!     if (CheckBuffer(self->buf))
  	return -1; /* ??? */
  
!     return (self->end - self->start + 1);
  }
  
      static PyObject *
! RangeItem(RangeObject *self, PyInt n)
  {
!     return RBItem(self->buf, n, self->start, self->end);
  }
  
      static PyObject *
! RangeSlice(RangeObject *self, PyInt lo, PyInt hi)
  {
!     return RBSlice(self->buf, lo, hi, self->start, self->end);
  }
  
      static PyObject *
! RangeAppend(RangeObject *self, PyObject *args)
  {
!     return RBAppend(self->buf, args, self->start, self->end, &self->end);
  }
  
      static PyObject *
! RangeRepr(RangeObject *self)
  {
      static char repr[100];
  
!     if (self->buf->buf == INVALID_BUFFER_VALUE)
      {
  	vim_snprintf(repr, 100, "<range object (for deleted buffer) at %p>",
  								      (self));
***************
*** 2977,2983 ****
      }
      else
      {
! 	char *name = (char *)this->buf->buf->b_fname;
  	int len;
  
  	if (name == NULL)
--- 2941,2947 ----
      }
      else
      {
! 	char *name = (char *)self->buf->buf->b_fname;
  	int len;
  
  	if (name == NULL)
***************
*** 2989,3004 ****
  
  	vim_snprintf(repr, 100, "<range %s%s (%d:%d)>",
  		len > 45 ? "..." : "", name,
! 		this->start, this->end);
  
  	return PyString_FromString(repr);
      }
  }
  
  static struct PyMethodDef RangeMethods[] = {
!     /* name,	    function,		calling,    documentation */
!     {"append",	    RangeAppend,	1,	    "Append data to the Vim range" },
!     { NULL,	    NULL,		0,	    NULL }
  };
  
  static PyTypeObject BufferType;
--- 2953,2968 ----
  
  	vim_snprintf(repr, 100, "<range %s%s (%d:%d)>",
  		len > 45 ? "..." : "", name,
! 		self->start, self->end);
  
  	return PyString_FromString(repr);
      }
  }
  
  static struct PyMethodDef RangeMethods[] = {
!     /* name,	function,			calling,	documentation */
!     {"append",	(PyCFunction)RangeAppend,	METH_VARARGS,	"Append data to the Vim range" },
!     { NULL,	NULL,				0,		NULL }
  };
  
  static PyTypeObject BufferType;
***************
*** 3045,3094 ****
  }
  
      static void
! BufferDestructor(PyObject *self)
  {
!     BufferObject *this = (BufferObject *)(self);
! 
!     if (this->buf && this->buf != INVALID_BUFFER_VALUE)
! 	BUF_PYTHON_REF(this->buf) = NULL;
  
      DESTRUCTOR_FINISH(self);
  }
  
      static PyInt
! BufferLength(PyObject *self)
  {
      /* HOW DO WE SIGNAL AN ERROR FROM THIS FUNCTION? */
!     if (CheckBuffer((BufferObject *)(self)))
  	return -1; /* ??? */
  
!     return (PyInt)(((BufferObject *)(self))->buf->b_ml.ml_line_count);
  }
  
      static PyObject *
! BufferItem(PyObject *self, PyInt n)
  {
!     return RBItem((BufferObject *)(self), n, 1, -1);
  }
  
      static PyObject *
! BufferSlice(PyObject *self, PyInt lo, PyInt hi)
  {
!     return RBSlice((BufferObject *)(self), lo, hi, 1, -1);
  }
  
      static PyObject *
! BufferAttr(BufferObject *this, char *name)
  {
      if (strcmp(name, "name") == 0)
! 	return Py_BuildValue("s", this->buf->b_ffname);
      else if (strcmp(name, "number") == 0)
! 	return Py_BuildValue(Py_ssize_t_fmt, this->buf->b_fnum);
      else if (strcmp(name, "vars") == 0)
! 	return DictionaryNew(this->buf->b_vars);
      else if (strcmp(name, "options") == 0)
! 	return OptionsNew(SREQ_BUF, this->buf, (checkfun) CheckBuffer,
! 			(PyObject *) this);
      else if (strcmp(name,"__members__") == 0)
  	return Py_BuildValue("[ssss]", "name", "number", "vars", "options");
      else
--- 3009,3056 ----
  }
  
      static void
! BufferDestructor(BufferObject *self)
  {
!     if (self->buf && self->buf != INVALID_BUFFER_VALUE)
! 	BUF_PYTHON_REF(self->buf) = NULL;
  
      DESTRUCTOR_FINISH(self);
  }
  
      static PyInt
! BufferLength(BufferObject *self)
  {
      /* HOW DO WE SIGNAL AN ERROR FROM THIS FUNCTION? */
!     if (CheckBuffer(self))
  	return -1; /* ??? */
  
!     return (PyInt)(self->buf->b_ml.ml_line_count);
  }
  
      static PyObject *
! BufferItem(BufferObject *self, PyInt n)
  {
!     return RBItem(self, n, 1, -1);
  }
  
      static PyObject *
! BufferSlice(BufferObject *self, PyInt lo, PyInt hi)
  {
!     return RBSlice(self, lo, hi, 1, -1);
  }
  
      static PyObject *
! BufferAttr(BufferObject *self, char *name)
  {
      if (strcmp(name, "name") == 0)
! 	return Py_BuildValue("s", self->buf->b_ffname);
      else if (strcmp(name, "number") == 0)
! 	return Py_BuildValue(Py_ssize_t_fmt, self->buf->b_fnum);
      else if (strcmp(name, "vars") == 0)
! 	return DictionaryNew(self->buf->b_vars);
      else if (strcmp(name, "options") == 0)
! 	return OptionsNew(SREQ_BUF, self->buf, (checkfun) CheckBuffer,
! 			(PyObject *) self);
      else if (strcmp(name,"__members__") == 0)
  	return Py_BuildValue("[ssss]", "name", "number", "vars", "options");
      else
***************
*** 3096,3122 ****
  }
  
      static PyObject *
! BufferAppend(PyObject *self, PyObject *args)
  {
!     return RBAppend((BufferObject *)(self), args, 1, -1, NULL);
  }
  
      static PyObject *
! BufferMark(PyObject *self, PyObject *args)
  {
      pos_T	*posp;
      char	*pmark;
      char	mark;
      buf_T	*savebuf;
  
!     if (CheckBuffer((BufferObject *)(self)))
  	return NULL;
  
      if (!PyArg_ParseTuple(args, "s", &pmark))
  	return NULL;
      mark = *pmark;
  
!     switch_buffer(&savebuf, ((BufferObject *)(self))->buf);
      posp = getmark(mark, FALSE);
      restore_buffer(savebuf);
  
--- 3058,3084 ----
  }
  
      static PyObject *
! BufferAppend(BufferObject *self, PyObject *args)
  {
!     return RBAppend(self, args, 1, -1, NULL);
  }
  
      static PyObject *
! BufferMark(BufferObject *self, PyObject *args)
  {
      pos_T	*posp;
      char	*pmark;
      char	mark;
      buf_T	*savebuf;
  
!     if (CheckBuffer(self))
  	return NULL;
  
      if (!PyArg_ParseTuple(args, "s", &pmark))
  	return NULL;
      mark = *pmark;
  
!     switch_buffer(&savebuf, self->buf);
      posp = getmark(mark, FALSE);
      restore_buffer(savebuf);
  
***************
*** 3141,3174 ****
  }
  
      static PyObject *
! BufferRange(PyObject *self, PyObject *args)
  {
      PyInt start;
      PyInt end;
  
!     if (CheckBuffer((BufferObject *)(self)))
  	return NULL;
  
      if (!PyArg_ParseTuple(args, "nn", &start, &end))
  	return NULL;
  
!     return RangeNew(((BufferObject *)(self))->buf, start, end);
  }
  
      static PyObject *
! BufferRepr(PyObject *self)
  {
      static char repr[100];
-     BufferObject *this = (BufferObject *)(self);
  
!     if (this->buf == INVALID_BUFFER_VALUE)
      {
  	vim_snprintf(repr, 100, _("<buffer object (deleted) at %p>"), (self));
  	return PyString_FromString(repr);
      }
      else
      {
! 	char *name = (char *)this->buf->b_fname;
  	PyInt len;
  
  	if (name == NULL)
--- 3103,3135 ----
  }
  
      static PyObject *
! BufferRange(BufferObject *self, PyObject *args)
  {
      PyInt start;
      PyInt end;
  
!     if (CheckBuffer(self))
  	return NULL;
  
      if (!PyArg_ParseTuple(args, "nn", &start, &end))
  	return NULL;
  
!     return RangeNew(self->buf, start, end);
  }
  
      static PyObject *
! BufferRepr(BufferObject *self)
  {
      static char repr[100];
  
!     if (self->buf == INVALID_BUFFER_VALUE)
      {
  	vim_snprintf(repr, 100, _("<buffer object (deleted) at %p>"), (self));
  	return PyString_FromString(repr);
      }
      else
      {
! 	char *name = (char *)self->buf->b_fname;
  	PyInt len;
  
  	if (name == NULL)
***************
*** 3185,3198 ****
  }
  
  static struct PyMethodDef BufferMethods[] = {
!     /* name,	    function,		calling,    documentation */
!     {"append",	    BufferAppend,	1,	    "Append data to Vim buffer" },
!     {"mark",	    BufferMark,		1,	    "Return (row,col) representing position of named mark" },
!     {"range",	    BufferRange,	1,	    "Return a range object which represents the part of the given buffer between line numbers s and e" },
  #if PY_VERSION_HEX >= 0x03000000
!     {"__dir__",	    BufferDir,		4,	    "List its attributes" },
  #endif
!     { NULL,	    NULL,		0,	    NULL }
  };
  
  /*
--- 3146,3159 ----
  }
  
  static struct PyMethodDef BufferMethods[] = {
!     /* name,	    function,			calling,	documentation */
!     {"append",	    (PyCFunction)BufferAppend,	METH_VARARGS,	"Append data to Vim buffer" },
!     {"mark",	    (PyCFunction)BufferMark,	METH_VARARGS,	"Return (row,col) representing position of named mark" },
!     {"range",	    (PyCFunction)BufferRange,	METH_VARARGS,	"Return a range object which represents the part of the given buffer between line numbers s and e" },
  #if PY_VERSION_HEX >= 0x03000000
!     {"__dir__",	    (PyCFunction)BufferDir,	METH_NOARGS,	"List buffer attributes" },
  #endif
!     { NULL,	    NULL,			0,		NULL }
  };
  
  /*
***************
*** 4021,4034 ****
      OutputType.tp_doc = "vim message object";
      OutputType.tp_methods = OutputMethods;
  #if PY_MAJOR_VERSION >= 3
!     OutputType.tp_getattro = OutputGetattro;
!     OutputType.tp_setattro = OutputSetattro;
      OutputType.tp_alloc = call_PyType_GenericAlloc;
      OutputType.tp_new = call_PyType_GenericNew;
      OutputType.tp_free = call_PyObject_Free;
  #else
!     OutputType.tp_getattr = OutputGetattr;
!     OutputType.tp_setattr = OutputSetattr;
  #endif
  
      vim_memset(&IterType, 0, sizeof(IterType));
--- 3982,3995 ----
      OutputType.tp_doc = "vim message object";
      OutputType.tp_methods = OutputMethods;
  #if PY_MAJOR_VERSION >= 3
!     OutputType.tp_getattro = (getattrofunc)OutputGetattro;
!     OutputType.tp_setattro = (setattrofunc)OutputSetattro;
      OutputType.tp_alloc = call_PyType_GenericAlloc;
      OutputType.tp_new = call_PyType_GenericNew;
      OutputType.tp_free = call_PyObject_Free;
  #else
!     OutputType.tp_getattr = (getattrfunc)OutputGetattr;
!     OutputType.tp_setattr = (setattrfunc)OutputSetattr;
  #endif
  
      vim_memset(&IterType, 0, sizeof(IterType));
***************
*** 4036,4102 ****
      IterType.tp_basicsize = sizeof(IterObject);
      IterType.tp_flags = Py_TPFLAGS_DEFAULT;
      IterType.tp_doc = "generic iterator object";
!     IterType.tp_iter = IterIter;
!     IterType.tp_iternext = IterNext;
!     IterType.tp_dealloc = IterDestructor;
!     IterType.tp_traverse = IterTraverse;
!     IterType.tp_clear = IterClear;
  
      vim_memset(&BufferType, 0, sizeof(BufferType));
      BufferType.tp_name = "vim.buffer";
      BufferType.tp_basicsize = sizeof(BufferType);
!     BufferType.tp_dealloc = BufferDestructor;
!     BufferType.tp_repr = BufferRepr;
      BufferType.tp_as_sequence = &BufferAsSeq;
      BufferType.tp_as_mapping = &BufferAsMapping;
      BufferType.tp_flags = Py_TPFLAGS_DEFAULT;
      BufferType.tp_doc = "vim buffer object";
      BufferType.tp_methods = BufferMethods;
  #if PY_MAJOR_VERSION >= 3
!     BufferType.tp_getattro = BufferGetattro;
      BufferType.tp_alloc = call_PyType_GenericAlloc;
      BufferType.tp_new = call_PyType_GenericNew;
      BufferType.tp_free = call_PyObject_Free;
  #else
!     BufferType.tp_getattr = BufferGetattr;
  #endif
  
      vim_memset(&WindowType, 0, sizeof(WindowType));
      WindowType.tp_name = "vim.window";
      WindowType.tp_basicsize = sizeof(WindowObject);
!     WindowType.tp_dealloc = WindowDestructor;
!     WindowType.tp_repr = WindowRepr;
      WindowType.tp_flags = Py_TPFLAGS_DEFAULT;
      WindowType.tp_doc = "vim Window object";
      WindowType.tp_methods = WindowMethods;
!     WindowType.tp_traverse = WindowTraverse;
!     WindowType.tp_clear = WindowClear;
  #if PY_MAJOR_VERSION >= 3
!     WindowType.tp_getattro = WindowGetattro;
!     WindowType.tp_setattro = WindowSetattro;
      WindowType.tp_alloc = call_PyType_GenericAlloc;
      WindowType.tp_new = call_PyType_GenericNew;
      WindowType.tp_free = call_PyObject_Free;
  #else
!     WindowType.tp_getattr = WindowGetattr;
!     WindowType.tp_setattr = WindowSetattr;
  #endif
  
      vim_memset(&TabPageType, 0, sizeof(TabPageType));
      TabPageType.tp_name = "vim.tabpage";
      TabPageType.tp_basicsize = sizeof(TabPageObject);
!     TabPageType.tp_dealloc = TabPageDestructor;
!     TabPageType.tp_repr = TabPageRepr;
      TabPageType.tp_flags = Py_TPFLAGS_DEFAULT;
      TabPageType.tp_doc = "vim tab page object";
      TabPageType.tp_methods = TabPageMethods;
  #if PY_MAJOR_VERSION >= 3
!     TabPageType.tp_getattro = TabPageGetattro;
      TabPageType.tp_alloc = call_PyType_GenericAlloc;
      TabPageType.tp_new = call_PyType_GenericNew;
      TabPageType.tp_free = call_PyObject_Free;
  #else
!     TabPageType.tp_getattr = TabPageGetattr;
  #endif
  
      vim_memset(&BufMapType, 0, sizeof(BufMapType));
--- 3997,4063 ----
      IterType.tp_basicsize = sizeof(IterObject);
      IterType.tp_flags = Py_TPFLAGS_DEFAULT;
      IterType.tp_doc = "generic iterator object";
!     IterType.tp_iter = (getiterfunc)IterIter;
!     IterType.tp_iternext = (iternextfunc)IterNext;
!     IterType.tp_dealloc = (destructor)IterDestructor;
!     IterType.tp_traverse = (traverseproc)IterTraverse;
!     IterType.tp_clear = (inquiry)IterClear;
  
      vim_memset(&BufferType, 0, sizeof(BufferType));
      BufferType.tp_name = "vim.buffer";
      BufferType.tp_basicsize = sizeof(BufferType);
!     BufferType.tp_dealloc = (destructor)BufferDestructor;
!     BufferType.tp_repr = (reprfunc)BufferRepr;
      BufferType.tp_as_sequence = &BufferAsSeq;
      BufferType.tp_as_mapping = &BufferAsMapping;
      BufferType.tp_flags = Py_TPFLAGS_DEFAULT;
      BufferType.tp_doc = "vim buffer object";
      BufferType.tp_methods = BufferMethods;
  #if PY_MAJOR_VERSION >= 3
!     BufferType.tp_getattro = (getattrofunc)BufferGetattro;
      BufferType.tp_alloc = call_PyType_GenericAlloc;
      BufferType.tp_new = call_PyType_GenericNew;
      BufferType.tp_free = call_PyObject_Free;
  #else
!     BufferType.tp_getattr = (getattrfunc)BufferGetattr;
  #endif
  
      vim_memset(&WindowType, 0, sizeof(WindowType));
      WindowType.tp_name = "vim.window";
      WindowType.tp_basicsize = sizeof(WindowObject);
!     WindowType.tp_dealloc = (destructor)WindowDestructor;
!     WindowType.tp_repr = (reprfunc)WindowRepr;
      WindowType.tp_flags = Py_TPFLAGS_DEFAULT;
      WindowType.tp_doc = "vim Window object";
      WindowType.tp_methods = WindowMethods;
!     WindowType.tp_traverse = (traverseproc)WindowTraverse;
!     WindowType.tp_clear = (inquiry)WindowClear;
  #if PY_MAJOR_VERSION >= 3
!     WindowType.tp_getattro = (getattrofunc)WindowGetattro;
!     WindowType.tp_setattro = (setattrofunc)WindowSetattro;
      WindowType.tp_alloc = call_PyType_GenericAlloc;
      WindowType.tp_new = call_PyType_GenericNew;
      WindowType.tp_free = call_PyObject_Free;
  #else
!     WindowType.tp_getattr = (getattrfunc)WindowGetattr;
!     WindowType.tp_setattr = (setattrfunc)WindowSetattr;
  #endif
  
      vim_memset(&TabPageType, 0, sizeof(TabPageType));
      TabPageType.tp_name = "vim.tabpage";
      TabPageType.tp_basicsize = sizeof(TabPageObject);
!     TabPageType.tp_dealloc = (destructor)TabPageDestructor;
!     TabPageType.tp_repr = (reprfunc)TabPageRepr;
      TabPageType.tp_flags = Py_TPFLAGS_DEFAULT;
      TabPageType.tp_doc = "vim tab page object";
      TabPageType.tp_methods = TabPageMethods;
  #if PY_MAJOR_VERSION >= 3
!     TabPageType.tp_getattro = (getattrofunc)TabPageGetattro;
      TabPageType.tp_alloc = call_PyType_GenericAlloc;
      TabPageType.tp_new = call_PyType_GenericNew;
      TabPageType.tp_free = call_PyObject_Free;
  #else
!     TabPageType.tp_getattr = (getattrfunc)TabPageGetattr;
  #endif
  
      vim_memset(&BufMapType, 0, sizeof(BufMapType));
***************
*** 4113,4119 ****
      WinListType.tp_as_sequence = &WinListAsSeq;
      WinListType.tp_flags = Py_TPFLAGS_DEFAULT;
      WinListType.tp_doc = "vim window list";
!     WinListType.tp_dealloc = WinListDestructor;
  
      vim_memset(&TabListType, 0, sizeof(TabListType));
      TabListType.tp_name = "vim.tabpagelist";
--- 4074,4080 ----
      WinListType.tp_as_sequence = &WinListAsSeq;
      WinListType.tp_flags = Py_TPFLAGS_DEFAULT;
      WinListType.tp_doc = "vim window list";
!     WinListType.tp_dealloc = (destructor)WinListDestructor;
  
      vim_memset(&TabListType, 0, sizeof(TabListType));
      TabListType.tp_name = "vim.tabpagelist";
***************
*** 4125,4144 ****
      vim_memset(&RangeType, 0, sizeof(RangeType));
      RangeType.tp_name = "vim.range";
      RangeType.tp_basicsize = sizeof(RangeObject);
!     RangeType.tp_dealloc = RangeDestructor;
!     RangeType.tp_repr = RangeRepr;
      RangeType.tp_as_sequence = &RangeAsSeq;
      RangeType.tp_as_mapping = &RangeAsMapping;
      RangeType.tp_flags = Py_TPFLAGS_DEFAULT;
      RangeType.tp_doc = "vim Range object";
      RangeType.tp_methods = RangeMethods;
  #if PY_MAJOR_VERSION >= 3
!     RangeType.tp_getattro = RangeGetattro;
      RangeType.tp_alloc = call_PyType_GenericAlloc;
      RangeType.tp_new = call_PyType_GenericNew;
      RangeType.tp_free = call_PyObject_Free;
  #else
!     RangeType.tp_getattr = RangeGetattr;
  #endif
  
      vim_memset(&CurrentType, 0, sizeof(CurrentType));
--- 4086,4105 ----
      vim_memset(&RangeType, 0, sizeof(RangeType));
      RangeType.tp_name = "vim.range";
      RangeType.tp_basicsize = sizeof(RangeObject);
!     RangeType.tp_dealloc = (destructor)RangeDestructor;
!     RangeType.tp_repr = (reprfunc)RangeRepr;
      RangeType.tp_as_sequence = &RangeAsSeq;
      RangeType.tp_as_mapping = &RangeAsMapping;
      RangeType.tp_flags = Py_TPFLAGS_DEFAULT;
      RangeType.tp_doc = "vim Range object";
      RangeType.tp_methods = RangeMethods;
  #if PY_MAJOR_VERSION >= 3
!     RangeType.tp_getattro = (getattrofunc)RangeGetattro;
      RangeType.tp_alloc = call_PyType_GenericAlloc;
      RangeType.tp_new = call_PyType_GenericNew;
      RangeType.tp_free = call_PyObject_Free;
  #else
!     RangeType.tp_getattr = (getattrfunc)RangeGetattr;
  #endif
  
      vim_memset(&CurrentType, 0, sizeof(CurrentType));
***************
*** 4147,4205 ****
      CurrentType.tp_flags = Py_TPFLAGS_DEFAULT;
      CurrentType.tp_doc = "vim current object";
  #if PY_MAJOR_VERSION >= 3
!     CurrentType.tp_getattro = CurrentGetattro;
!     CurrentType.tp_setattro = CurrentSetattro;
  #else
!     CurrentType.tp_getattr = CurrentGetattr;
!     CurrentType.tp_setattr = CurrentSetattr;
  #endif
  
      vim_memset(&DictionaryType, 0, sizeof(DictionaryType));
      DictionaryType.tp_name = "vim.dictionary";
      DictionaryType.tp_basicsize = sizeof(DictionaryObject);
!     DictionaryType.tp_dealloc = DictionaryDestructor;
      DictionaryType.tp_as_mapping = &DictionaryAsMapping;
      DictionaryType.tp_flags = Py_TPFLAGS_DEFAULT;
      DictionaryType.tp_doc = "dictionary pushing modifications to vim structure";
      DictionaryType.tp_methods = DictionaryMethods;
  #if PY_MAJOR_VERSION >= 3
!     DictionaryType.tp_getattro = DictionaryGetattro;
!     DictionaryType.tp_setattro = DictionarySetattro;
  #else
!     DictionaryType.tp_getattr = DictionaryGetattr;
!     DictionaryType.tp_setattr = DictionarySetattr;
  #endif
  
      vim_memset(&ListType, 0, sizeof(ListType));
      ListType.tp_name = "vim.list";
!     ListType.tp_dealloc = ListDestructor;
      ListType.tp_basicsize = sizeof(ListObject);
      ListType.tp_as_sequence = &ListAsSeq;
      ListType.tp_as_mapping = &ListAsMapping;
      ListType.tp_flags = Py_TPFLAGS_DEFAULT;
      ListType.tp_doc = "list pushing modifications to vim structure";
      ListType.tp_methods = ListMethods;
!     ListType.tp_iter = ListIter;
  #if PY_MAJOR_VERSION >= 3
!     ListType.tp_getattro = ListGetattro;
!     ListType.tp_setattro = ListSetattro;
  #else
!     ListType.tp_getattr = ListGetattr;
!     ListType.tp_setattr = ListSetattr;
  #endif
  
      vim_memset(&FunctionType, 0, sizeof(FunctionType));
      FunctionType.tp_name = "vim.function";
      FunctionType.tp_basicsize = sizeof(FunctionObject);
!     FunctionType.tp_dealloc = FunctionDestructor;
!     FunctionType.tp_call = FunctionCall;
      FunctionType.tp_flags = Py_TPFLAGS_DEFAULT;
      FunctionType.tp_doc = "object that calls vim function";
      FunctionType.tp_methods = FunctionMethods;
  #if PY_MAJOR_VERSION >= 3
!     FunctionType.tp_getattro = FunctionGetattro;
  #else
!     FunctionType.tp_getattr = FunctionGetattr;
  #endif
  
      vim_memset(&OptionsType, 0, sizeof(OptionsType));
--- 4108,4166 ----
      CurrentType.tp_flags = Py_TPFLAGS_DEFAULT;
      CurrentType.tp_doc = "vim current object";
  #if PY_MAJOR_VERSION >= 3
!     CurrentType.tp_getattro = (getattrofunc)CurrentGetattro;
!     CurrentType.tp_setattro = (setattrofunc)CurrentSetattro;
  #else
!     CurrentType.tp_getattr = (getattrfunc)CurrentGetattr;
!     CurrentType.tp_setattr = (setattrfunc)CurrentSetattr;
  #endif
  
      vim_memset(&DictionaryType, 0, sizeof(DictionaryType));
      DictionaryType.tp_name = "vim.dictionary";
      DictionaryType.tp_basicsize = sizeof(DictionaryObject);
!     DictionaryType.tp_dealloc = (destructor)DictionaryDestructor;
      DictionaryType.tp_as_mapping = &DictionaryAsMapping;
      DictionaryType.tp_flags = Py_TPFLAGS_DEFAULT;
      DictionaryType.tp_doc = "dictionary pushing modifications to vim structure";
      DictionaryType.tp_methods = DictionaryMethods;
  #if PY_MAJOR_VERSION >= 3
!     DictionaryType.tp_getattro = (getattrofunc)DictionaryGetattro;
!     DictionaryType.tp_setattro = (setattrofunc)DictionarySetattro;
  #else
!     DictionaryType.tp_getattr = (getattrfunc)DictionaryGetattr;
!     DictionaryType.tp_setattr = (setattrfunc)DictionarySetattr;
  #endif
  
      vim_memset(&ListType, 0, sizeof(ListType));
      ListType.tp_name = "vim.list";
!     ListType.tp_dealloc = (destructor)ListDestructor;
      ListType.tp_basicsize = sizeof(ListObject);
      ListType.tp_as_sequence = &ListAsSeq;
      ListType.tp_as_mapping = &ListAsMapping;
      ListType.tp_flags = Py_TPFLAGS_DEFAULT;
      ListType.tp_doc = "list pushing modifications to vim structure";
      ListType.tp_methods = ListMethods;
!     ListType.tp_iter = (getiterfunc)ListIter;
  #if PY_MAJOR_VERSION >= 3
!     ListType.tp_getattro = (getattrofunc)ListGetattro;
!     ListType.tp_setattro = (setattrofunc)ListSetattro;
  #else
!     ListType.tp_getattr = (getattrfunc)ListGetattr;
!     ListType.tp_setattr = (setattrfunc)ListSetattr;
  #endif
  
      vim_memset(&FunctionType, 0, sizeof(FunctionType));
      FunctionType.tp_name = "vim.function";
      FunctionType.tp_basicsize = sizeof(FunctionObject);
!     FunctionType.tp_dealloc = (destructor)FunctionDestructor;
!     FunctionType.tp_call = (ternaryfunc)FunctionCall;
      FunctionType.tp_flags = Py_TPFLAGS_DEFAULT;
      FunctionType.tp_doc = "object that calls vim function";
      FunctionType.tp_methods = FunctionMethods;
  #if PY_MAJOR_VERSION >= 3
!     FunctionType.tp_getattro = (getattrofunc)FunctionGetattro;
  #else
!     FunctionType.tp_getattr = (getattrfunc)FunctionGetattr;
  #endif
  
      vim_memset(&OptionsType, 0, sizeof(OptionsType));
***************
*** 4208,4216 ****
      OptionsType.tp_flags = Py_TPFLAGS_DEFAULT;
      OptionsType.tp_doc = "object for manipulating options";
      OptionsType.tp_as_mapping = &OptionsAsMapping;
!     OptionsType.tp_dealloc = OptionsDestructor;
!     OptionsType.tp_traverse = OptionsTraverse;
!     OptionsType.tp_clear = OptionsClear;
  
  #if PY_MAJOR_VERSION >= 3
      vim_memset(&vimmodule, 0, sizeof(vimmodule));
--- 4169,4177 ----
      OptionsType.tp_flags = Py_TPFLAGS_DEFAULT;
      OptionsType.tp_doc = "object for manipulating options";
      OptionsType.tp_as_mapping = &OptionsAsMapping;
!     OptionsType.tp_dealloc = (destructor)OptionsDestructor;
!     OptionsType.tp_traverse = (traverseproc)OptionsTraverse;
!     OptionsType.tp_clear = (inquiry)OptionsClear;
  
  #if PY_MAJOR_VERSION >= 3
      vim_memset(&vimmodule, 0, sizeof(vimmodule));
*** ../vim-7.3.991/src/if_python3.c	2013-05-21 18:19:33.000000000 +0200
--- src/if_python3.c	2013-05-21 18:22:03.000000000 +0200
***************
*** 68,75 ****
  # define PY_SSIZE_T_CLEAN
  #endif
  
- static void init_structs(void);
- 
  /* The "surrogateescape" error handler is new in Python 3.1 */
  #if PY_VERSION_HEX >= 0x030100f0
  # define CODEC_ERROR_HANDLER "surrogateescape"
--- 68,73 ----
***************
*** 610,617 ****
  }
  #endif /* DYNAMIC_PYTHON3 */
  
- static PyObject *BufferDir(PyObject *, PyObject *);
- 
  static int py3initialised = 0;
  
  #define PYINITIALISED py3initialised
--- 608,613 ----
***************
*** 670,675 ****
--- 666,672 ----
      return PyType_GenericAlloc(type,nitems);
  }
  
+ static PyObject *BufferDir(PyObject *);
  static PyObject *OutputGetattro(PyObject *, PyObject *);
  static int OutputSetattro(PyObject *, PyObject *, PyObject *);
  static PyObject *BufferGetattro(PyObject *, PyObject *);
***************
*** 1008,1014 ****
  {
      GET_ATTR_STRING(name, nameobj);
  
!     return OutputSetattr(self, name, val);
  }
  
  /***************/
--- 1005,1011 ----
  {
      GET_ATTR_STRING(name, nameobj);
  
!     return OutputSetattr((OutputObject *)(self), name, val);
  }
  
  /***************/
***************
*** 1036,1047 ****
  
  #define BufferType_Check(obj) ((obj)->ob_base.ob_type == &BufferType)
  
- static Py_ssize_t BufferLength(PyObject *);
- static PyObject *BufferItem(PyObject *, Py_ssize_t);
  static PyObject* BufferSubscript(PyObject *self, PyObject *idx);
  static Py_ssize_t BufferAsSubscript(PyObject *self, PyObject *idx, PyObject *val);
  
- 
  /* Line range type - Implementation functions
   * --------------------------------------
   */
--- 1033,1041 ----
***************
*** 1097,1103 ****
  }
  
      static PyObject *
! BufferDir(PyObject *self UNUSED, PyObject *args UNUSED)
  {
      return Py_BuildValue("[sssss]", "name", "number",
  						   "append", "mark", "range");
--- 1091,1097 ----
  }
  
      static PyObject *
! BufferDir(PyObject *self UNUSED)
  {
      return Py_BuildValue("[sssss]", "name", "number",
  						   "append", "mark", "range");
***************
*** 1111,1117 ****
      if (PyLong_Check(idx))
      {
  	long _idx = PyLong_AsLong(idx);
! 	return BufferItem(self,_idx);
      } else if (PySlice_Check(idx))
      {
  	Py_ssize_t start, stop, step, slicelen;
--- 1105,1111 ----
      if (PyLong_Check(idx))
      {
  	long _idx = PyLong_AsLong(idx);
! 	return BufferItem((BufferObject *)(self), _idx);
      } else if (PySlice_Check(idx))
      {
  	Py_ssize_t start, stop, step, slicelen;
***************
*** 1126,1132 ****
  	{
  	    return NULL;
  	}
! 	return BufferSlice(self, start, stop);
      }
      else
      {
--- 1120,1126 ----
  	{
  	    return NULL;
  	}
! 	return BufferSlice((BufferObject *)(self), start, stop);
      }
      else
      {
***************
*** 1230,1236 ****
      if (PyLong_Check(idx))
      {
  	long _idx = PyLong_AsLong(idx);
! 	return RangeItem(self,_idx);
      } else if (PySlice_Check(idx))
      {
  	Py_ssize_t start, stop, step, slicelen;
--- 1224,1230 ----
      if (PyLong_Check(idx))
      {
  	long _idx = PyLong_AsLong(idx);
! 	return RangeItem((RangeObject *)(self), _idx);
      } else if (PySlice_Check(idx))
      {
  	Py_ssize_t start, stop, step, slicelen;
***************
*** 1242,1248 ****
  	{
  	    return NULL;
  	}
! 	return RangeSlice(self, start, stop);
      }
      else
      {
--- 1236,1242 ----
  	{
  	    return NULL;
  	}
! 	return RangeSlice((RangeObject *)(self), start, stop);
      }
      else
      {
***************
*** 1323,1329 ****
  {
      GET_ATTR_STRING(name, nameobj);
  
!     return WindowSetattr(self, name, val);
  }
  
  /* Tab page list object - Definitions
--- 1317,1323 ----
  {
      GET_ATTR_STRING(name, nameobj);
  
!     return WindowSetattr((WindowObject *)(self), name, val);
  }
  
  /* Tab page list object - Definitions
***************
*** 1377,1384 ****
  /* Dictionary object - Definitions
   */
  
- static PyInt DictionaryLength(PyObject *);
- 
      static PyObject *
  DictionaryGetattro(PyObject *self, PyObject *nameobj)
  {
--- 1371,1376 ----
***************
*** 1398,1412 ****
  DictionarySetattro(PyObject *self, PyObject *nameobj, PyObject *val)
  {
      GET_ATTR_STRING(name, nameobj);
!     return DictionarySetattr(self, name, val);
  }
  
  /* List object - Definitions
   */
  
- static PyInt ListLength(PyObject *);
- static PyObject *ListItem(PyObject *, Py_ssize_t);
- 
  static PySequenceMethods ListAsSeq = {
      (lenfunc)		ListLength,	 /* sq_length,	  len(x)   */
      (binaryfunc)	0,		 /* RangeConcat, sq_concat,  x+y   */
--- 1390,1401 ----
  DictionarySetattro(PyObject *self, PyObject *nameobj, PyObject *val)
  {
      GET_ATTR_STRING(name, nameobj);
!     return DictionarySetattr((DictionaryObject *)(self), name, val);
  }
  
  /* List object - Definitions
   */
  
  static PySequenceMethods ListAsSeq = {
      (lenfunc)		ListLength,	 /* sq_length,	  len(x)   */
      (binaryfunc)	0,		 /* RangeConcat, sq_concat,  x+y   */
***************
*** 1430,1450 ****
  };
  
      static PyObject *
! ListSubscript(PyObject *self, PyObject* idxObject)
  {
!     if (PyLong_Check(idxObject))
      {
! 	long idx = PyLong_AsLong(idxObject);
! 	return ListItem(self, idx);
      }
!     else if (PySlice_Check(idxObject))
      {
  	Py_ssize_t start, stop, step, slicelen;
  
! 	if (PySlice_GetIndicesEx(idxObject, ListLength(self), &start, &stop,
! 				 &step, &slicelen) < 0)
  	    return NULL;
! 	return ListSlice(self, start, stop);
      }
      else
      {
--- 1419,1439 ----
  };
  
      static PyObject *
! ListSubscript(PyObject *self, PyObject* idx)
  {
!     if (PyLong_Check(idx))
      {
! 	long _idx = PyLong_AsLong(idx);
! 	return ListItem((ListObject *)(self), _idx);
      }
!     else if (PySlice_Check(idx))
      {
  	Py_ssize_t start, stop, step, slicelen;
  
! 	if (PySlice_GetIndicesEx(idx, ListLength((ListObject *)(self)),
! 				 &start, &stop, &step, &slicelen) < 0)
  	    return NULL;
! 	return ListSlice((ListObject *)(self), start, stop);
      }
      else
      {
***************
*** 1454,1474 ****
  }
  
      static Py_ssize_t
! ListAsSubscript(PyObject *self, PyObject *idxObject, PyObject *obj)
  {
!     if (PyLong_Check(idxObject))
      {
! 	long idx = PyLong_AsLong(idxObject);
! 	return ListAssItem(self, idx, obj);
      }
!     else if (PySlice_Check(idxObject))
      {
  	Py_ssize_t start, stop, step, slicelen;
  
! 	if (PySlice_GetIndicesEx(idxObject, ListLength(self), &start, &stop,
! 				 &step, &slicelen) < 0)
  	    return -1;
! 	return ListAssSlice(self, start, stop, obj);
      }
      else
      {
--- 1443,1463 ----
  }
  
      static Py_ssize_t
! ListAsSubscript(PyObject *self, PyObject *idx, PyObject *obj)
  {
!     if (PyLong_Check(idx))
      {
! 	long _idx = PyLong_AsLong(idx);
! 	return ListAssItem((ListObject *)(self), _idx, obj);
      }
!     else if (PySlice_Check(idx))
      {
  	Py_ssize_t start, stop, step, slicelen;
  
! 	if (PySlice_GetIndicesEx(idx, ListLength((ListObject *)(self)),
! 				 &start, &stop, &step, &slicelen) < 0)
  	    return -1;
! 	return ListAssSlice((ListObject *)(self), start, stop, obj);
      }
      else
      {
***************
*** 1492,1498 ****
  ListSetattro(PyObject *self, PyObject *nameobj, PyObject *val)
  {
      GET_ATTR_STRING(name, nameobj);
!     return ListSetattr(self, name, val);
  }
  
  /* Function object - Definitions
--- 1481,1487 ----
  ListSetattro(PyObject *self, PyObject *nameobj, PyObject *val)
  {
      GET_ATTR_STRING(name, nameobj);
!     return ListSetattr((ListObject *)(self), name, val);
  }
  
  /* Function object - Definitions
*** ../vim-7.3.991/src/if_python.c	2013-05-21 18:19:33.000000000 +0200
--- src/if_python.c	2013-05-21 18:22:03.000000000 +0200
***************
*** 56,63 ****
  # define PY_SSIZE_T_CLEAN
  #endif
  
- static void init_structs(void);
- 
  #define PyBytes_FromString PyString_FromString
  #define PyBytes_Check PyString_Check
  
--- 56,61 ----
***************
*** 659,674 ****
   * Internal function prototypes.
   */
  
- static void PythonIO_Flush(void);
  static int PythonIO_Init(void);
  static int PythonMod_Init(void);
  
- /* Utility functions for the vim/python interface
-  * ----------------------------------------------
-  */
- 
- static int SetBufferLineList(buf_T *, PyInt, PyInt, PyObject *, PyInt *);
- 
  
  /******************************************************
   * 1. Python interpreter main program.
--- 657,665 ----
***************
*** 1017,1025 ****
   * 3. Implementation of the Vim module for Python
   */
  
- static PyObject *ConvertToPyObject(typval_T *);
- static int ConvertFromPyObject(PyObject *, typval_T *);
- 
  /* Window type - Implementation functions
   * --------------------------------------
   */
--- 1008,1013 ----
*** ../vim-7.3.991/src/version.c	2013-05-21 18:19:33.000000000 +0200
--- src/version.c	2013-05-21 18:28:18.000000000 +0200
***************
*** 730,731 ****
--- 730,733 ----
  {   /* Add new patch number below this line */
+ /**/
+     992,
  /**/

-- 
We apologise again for the fault in the subtitles.  Those responsible for
sacking the people who have just been sacked have been sacked.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
